<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>中文教程：用R构建Shiny应用程序</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<base target="_blank"/>

<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,400italic,600italic,700italic' rel='stylesheet' type='text/css'>
<style>
   body {
     padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
     font-family: 'Source Sans Pro', sans-serif;
     font-size: 18px;
     line-height: 1.5;
   }
   .responsive-image {
      max-width: 100%;
   }
   .console {
      color: blue;
   }
   code {
     background-color: transparent;
     border: none;
     padding: 0;
     color: #5F504D;
   }
   dt {
     margin-top: 20px;
     margin-bottom: 4px;
   }
   dd {
     margin-left: 30px;
   }
   h2 {
     font-size: 30px;
   }
   h3 {
     font-size: 22px;
     margin-top: 30px;
     margin-bottom: 10px;
   }
   
   li{ line-height: 25px;}
   
   code, pre{ font-size: 18px; }
   
   h1{ margin-bottom:20px }
   
   ul.nav > li.nav-header{font-size: 17px; }
   
   ul.nav-list li{font-size: 15px;}
      
</style>
<link href="bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">

<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
<!--[if lt IE 9]>
   <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->


<!-- Styles for R syntax highlighter -->
<style type="text/css">
   tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console',       Consolas, Monaco, monospace;
   }
   
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<script src="jquery.js"></script>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27377274-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>

<!-- Top navigation bar -->
<div class="navbar navbar-fixed-top">
<div class="navbar-inner">
  <div class="container">
   
    <a class="brand" href="#" target="_self">中文教程：用R构建Shiny应用程序</a>
    <a class="btn btn-primary pull-right" href="http://rstudio.github.io/shiny/tutorial" target="_blank">英文版教程</a>
   <a class="btn btn-primary pull-right" href="https://github.com/rstudio/shiny" target="_blank">Shiny on GitHub</a>
   
  </div>
</div>
</div>

<!-- Document body -->
<div class="container-fluid">
<div class="row-fluid">

<!-- Side navigation bar -->
<div class="span4 well">
<ul class = "nav nav-list">
   <li class="nav-header">入门</li>
    <li class="active">
      <a target="_self" href="#welcome">欢迎</a>
   </li>
   <li>
      <a target="_self" href="#hello-shiny">Hello Shiny</a>
   </li>
   <li>
      <a target="_self" href="#shiny-text">Shiny文本</a>
   </li>
   <li>
      <a target="_self" href="#reactivity">交互</a>
   </li>
   <li class="nav-header">构建App</li>
   <li>
      <a target="_self" href="#ui-and-server">UI&amp;服务器</a>
   </li>
   <li>
      <a target="_self" href="#inputs-and-outputs">输入&amp;输出</a>
   </li>
   <li>
      <a target="_self" href="#run-and-debug">运行&amp;调试</a>
   </li>
   <li class="nav-header">Tooling Up</li>
   <li>
      <a target="_self" href="#sliders">滑动条</a>
   </li>
   <li>
      <a target="_self" href="#tabsets">表格</a>
   </li>
   <li>
      <a target="_self" href="#more-widgets">更多小工具</a>
   </li>
   <li>
      <a target="_self" href="#uploads">上传文件</a>
   </li>
   <li>
      <a target="_self" href="#downloads">下载数据</a>
   </li>
   <li>
      <a target="_self" href="#html-ui">HTML UI</a>
   </li>
   <li>
      <a target="_self" href="#dynamic-ui">动态UI</a>
   </li>
   <li class="nav-header">高级Shiny技巧</li>
   <li>
      <a target="_self" href="#scoping">Scoping</a>
   </li>
   <li>
      <a target="_self" href="#client-data">客户端数据</a>
   </li>
   <li>
      <a target="_self" href="#sending-images">发送图片</a>
   </li>
   <li class="nav-header">理解被动式</li>
   <li>
      <a target="_self" href="#reactivity-overview">概述被动式</a>
   </li>
   <li>
      <a target="_self" href="#execution-scheduling">Execution Scheduling</a>
   </li>
   <li>
      <a target="_self" href="#isolation">Isolation</a>
   </li>
   <li class="nav-header">部署和分享Apps</li>
   <li>
      <a target="_self" href="#deployment-web">通过web部署</a>
   </li>
   <li>
      <a target="_self" href="#deployment-local">分享Apps以供本地运行</a>
   </li>
   <li class="nav-header">扩展Shiny</li>
   <li>
      <a target="_self" href="#building-inputs">构建输入</a>
   </li>
   <li>
      <a target="_self" href="#building-outputs">构建输出</a>
   </li>
<!--
   <li>
      <a target="_self" href="#packaging-components">Packaging Components</a>
   </li>
 -->
</ul>
</div>

<!-- Tabs -->
<div class="span8 tab-content">
   
<!-- Welcome -->   
<div class="tab-pane active" id="welcome">


<h1 id='shiny'>Shiny简介</h1>

<p>Shiny是RStudio公司开发的新包，有了它，可以用R语言轻松开发交互式web应用。</p>

<p>想查看更详细的介绍和实例，请访问<a href='http://www.rstudio.com/shiny'>Shiny的官方主页</a>。</p>

<h3 id='id43'>特性</h3>

<ul>
<li>只用几行代码就可以构建有用的web应用程序&#8212;不需要用JavaScript。</li>

<li>Shiny应用程序会自动刷新计算结果，这与电子表格实时计算的效果类似。 当用户修改输入时，输出值自动更新，而不需要在浏览器中手动刷新。</li>

<li>Shiny用户界面可以用纯R语言构建，如果想更灵活，可以直接用HTML、CSS和JavaScript来写。</li>

<li>可以在任何R环境中运行（R命令行、Windows或Mac中的Rgui、ESS、StatET、RStudio等）</li>

<li>基于<a href='http://twitter.github.com/bootstrap'>Twitter Bootstrap</a>的默认UI主题很吸引人。</li>

<li>高度定制化的滑动条小工具（slider widget），内置了对动画的支持。</li>

<li>预先构建有输出小工具，用来展示图形、表格以及打印输出R对象。</li>

<li>采用<a href='http://illposed.net/websockets.html'>websockets</a>包，做到浏览器和R之间快速双向通信。</li>

<li>采用<a href='http://en.wikipedia.org/wiki/Reactive_programming'>被动式（reactive）</a>编程模型，摒弃了繁杂的 事件处理代码，这样你可以集中精力于真正关心的代码上。</li>

<li>开发和分发你自己的Shiny小工具，其他开发者也可以非常容易地加到自己的应用中（即将面市！）</li>
</ul>

<h3 id='id44'>安装</h3>

<p>Shiny可以从CRAN获取， 所以你可以用通常的方式来安装，在R的命令行里输入：</p>

<p><code>r
install.packages(&quot;shiny&quot;)
</code></p>

<h3 id='lets_go'>Let&#8217;s Go!</h3>

<p>本教程涵盖了Shiny的基础知识，提供了详尽的案例来展示它的各种特性。点击Next按钮对Shiny说hello吧！</p>
      
</div>
      

<!-- Hello Shiny -->      
<div class="tab-pane" id="hello-shiny">


<p><img alt='Hello Shiny Screenshot' src='screenshots/hello-shiny.png' /></p>

<p>The Hello Shiny example is a simple application that generates a random distribution with a configurable number of observations and then plots it. To run the example, type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;01_hello&quot;)</code></pre>
</div>
<p>Shiny applications have two components: a user-interface definition and a server script. The source code for both of these components is listed below.</p>

<p>In subsequent sections of the tutorial we&#8217;ll break down all of the code in detail and explain the use of &#8220;reactive&#8221; expressions for generating output. For now, though, just try playing with the sample application and reviewing the source code to get an initial feel for things. Be sure to read the comments carefully.</p>

<p>The user interface is defined in a source file named ui.R:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for application that plots random distributions 
shinyUI(pageWithSidebar(

  # Application title
  headerPanel(&quot;Hello Shiny!&quot;),

  # Sidebar with a slider input for number of observations
  sidebarPanel(
    sliderInput(&quot;obs&quot;, 
                &quot;Number of observations:&quot;, 
                min = 0, 
                max = 1000, 
                value = 500)
  ),

  # Show a plot of the generated distribution
  mainPanel(
    plotOutput(&quot;distPlot&quot;)
  )
))</code></pre>
</div>
<p>The server-side of the application is shown below. At one level, it&#8217;s very simple&#8211;a random distribution with the requested number of observations is generated, and then plotted as a histogram. However, you&#8217;ll also notice that the function which returns the plot is wrapped in a call to <code>renderPlot</code>. The comment above the function explains a bit about this, but if you find it confusing, don&#8217;t worry&#8211;we&#8217;ll cover this concept in much more detail soon.</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define server logic required to generate and plot a random distribution
shinyServer(function(input, output) {

  # Expression that generates a plot of the distribution. The expression
  # is wrapped in a call to renderPlot to indicate that:
  #
  #  1) It is &quot;reactive&quot; and therefore should be automatically 
  #     re-executed when inputs change
  #  2) Its output type is a plot 
  #
  output$distPlot &lt;- renderPlot({

    # generate an rnorm distribution and plot it
    dist &lt;- rnorm(input$obs)
    hist(dist)
  })
})</code></pre>
</div>
<p>The next example will show the use of more input controls, as well as the use of reactive functions to generate textual output.</p>

</div>

<!-- Shiny Text -->
<div class="tab-pane" id="shiny-text">


<p><img alt='Tabsets Screenshot' src='screenshots/shiny-text.png' /></p>

<p>The Shiny Text application demonstrates printing R objects directly, as well as displaying data frames using HTML tables. To run the example, type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;02_text&quot;)</code></pre>
</div>
<p>The first example had a single numeric input specified using a slider and a single plot output. This example has a bit more going on: two inputs and two types of textual output.</p>

<p>If you try changing the number of observations to another value, you&#8217;ll see a demonstration of one of the most important attributes of Shiny applications: inputs and outputs are connected together &#8220;live&#8221; and changes are propagated immediately (like a spreadsheet). In this case, rather than the entire page being reloaded, just the table view is updated when the number of observations change.</p>

<p>Here is the user interface definition for the application. Notice in particular that the <code>sidebarPanel</code> and <code>mainPanel</code> functions are now called with two arguments (corresponding to the two inputs and two outputs displayed):</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for dataset viewer application
shinyUI(pageWithSidebar(

  # Application title
  headerPanel(&quot;Shiny Text&quot;),

  # Sidebar with controls to select a dataset and specify the number
  # of observations to view
  sidebarPanel(
    selectInput(&quot;dataset&quot;, &quot;Choose a dataset:&quot;, 
                choices = c(&quot;rock&quot;, &quot;pressure&quot;, &quot;cars&quot;)),

    numericInput(&quot;obs&quot;, &quot;Number of observations to view:&quot;, 10)
  ),

  # Show a summary of the dataset and an HTML table with the requested
  # number of observations
  mainPanel(
    verbatimTextOutput(&quot;summary&quot;),

    tableOutput(&quot;view&quot;)
  )
))</code></pre>
</div>
<p>The server side of the application has also gotten a bit more complicated. Now we create:</p>

<ul>
<li>A reactive expression to return the dataset corresponding to the user choice</li>

<li>Two other rendering expressions (<code>renderPrint</code> and <code>renderTable</code>) that return the <code>output$summary</code> and <code>output$view</code> values</li>
</ul>

<p>These expressions work similarly to the <code>renderPlot</code> expression used in the first example: by declaring a rendering expression you tell Shiny that it should only be executed when its dependencies change. In this case that&#8217;s either one of the user input values (<code>input$dataset</code> or <code>input$n</code>).</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)
library(datasets)

# Define server logic required to summarize and view the selected dataset
shinyServer(function(input, output) {

  # Return the requested dataset
  datasetInput &lt;- reactive({
    switch(input$dataset,
           &quot;rock&quot; = rock,
           &quot;pressure&quot; = pressure,
           &quot;cars&quot; = cars)
  })

  # Generate a summary of the dataset
  output$summary &lt;- renderPrint({
    dataset &lt;- datasetInput()
    summary(dataset)
  })

  # Show the first &quot;n&quot; observations
  output$view &lt;- renderTable({
    head(datasetInput(), n = input$obs)
  })
})</code></pre>
</div>
<p>We&#8217;ve introduced more use of reactive expressions but haven&#8217;t really explained how they work yet. The next example will start with this one as a baseline and expand significantly on how reactive expressions work in Shiny.</p>

</div>


<!-- Reactivity -->
<div class="tab-pane" id="reactivity">


<p><img alt='Reactivity Screenshot' src='screenshots/reactivity.png' /></p>

<p>The Reactivity application is very similar to Hello Text, but goes into much more detail about reactive programming concepts. To run the example, type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;03_reactivity&quot;)</code></pre>
</div>
<p>The previous examples have given you a good idea of what the code for Shiny applications looks like. We&#8217;ve explained a bit about reactivity, but mostly glossed over the details. In this section, we&#8217;ll explore these concepts more deeply. If you want to dive in and learn about the details, see the Understanding Reactivity section, starting with <a href='#reactivity-overview'>Reactivity Overview</a>.</p>

<h3 id='what_is_reactivity'>What is Reactivity?</h3>

<p>The Shiny web framework is fundamentally about making it easy to wire up <em>input values</em> from a web page, making them easily available to you in R, and have the results of your R code be written as <em>output values</em> back out to the web page.</p>

<pre><code>input values =&gt; R code =&gt; output values</code></pre>

<p>Since Shiny web apps are interactive, the input values can change at any time, and the output values need to be updated immediately to reflect those changes.</p>

<p>Shiny comes with a <strong>reactive programming</strong> library that you will use to structure your application logic. By using this library, changing input values will naturally cause the right parts of your R code to be reexecuted, which will in turn cause any changed outputs to be updated.</p>

<h3 id='reactive_programming_basics'>Reactive Programming Basics</h3>

<p>Reactive programming is a coding style that starts with <strong>reactive values</strong>&#8211;values that change over time, or in response to the user&#8211;and builds on top of them with <strong>reactive expressions</strong>&#8211;expressions that access reactive values and execute other reactive expressions.</p>

<p>What&#8217;s interesting about reactive expressions is that whenever they execute, they automatically keep track of what reactive values they read and what reactive expressions they invoked. If those &#8220;dependencies&#8221; become out of date, then they know that their own return value has also become out of date. Because of this dependency tracking, changing a reactive value will automatically instruct all reactive expressions that directly or indirectly depended on that value to re-execute.</p>

<p>The most common way you&#8217;ll encounter reactive values in Shiny is using the <code>input</code> object. The <code>input</code> object, which is passed to your <code>shinyServer</code> function, lets you access the web page&#8217;s user input fields using a list-like syntax. Code-wise, it looks like you&#8217;re grabbing a value from a list or data frame, but you&#8217;re actually reading a reactive value. No need to write code to monitor when inputs change&#8211;just write reactive expression that read the inputs they need, and let Shiny take care of knowing when to call them.</p>

<p>It&#8217;s simple to create reactive expression: just pass a normal expression into <code>reactive</code>. In this application, an example of that is the expression that returns an R data frame based on the selection the user made in the input form:</p>
<div>
  <pre><code class='r'>datasetInput &lt;- reactive({
   switch(input$dataset,
          &quot;rock&quot; = rock,
          &quot;pressure&quot; = pressure,
          &quot;cars&quot; = cars)
})</code></pre>
</div>
<p>To turn reactive values into outputs that can viewed on the web page, we assigned them to the <code>output</code> object (also passed to the <code>shinyServer</code> function). Here is an example of an assignment to an output that depends on both the <code>datasetInput</code> reactive expression we just defined, as well as <code>input$obs</code>:</p>
<div>
  <pre><code class='r'>output$view &lt;- renderTable({
   head(datasetInput(), n = input$obs)
})</code></pre>
</div>
<p>This expression will be re-executed (and its output re-rendered in the browser) whenever either the <code>datasetInput</code> or <code>input$obs</code> value changes.</p>

<h3 id='back_to_the_code'>Back to the Code</h3>

<p>Now that we&#8217;ve taken a deeper loop at some of the core concepts, let&#8217;s revisit the source code and try to understand what&#8217;s going on in more depth. The user interface definition has been updated to include a text-input field that defines a caption. Other than that it&#8217;s very similar to the previous example:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for dataset viewer application
shinyUI(pageWithSidebar(

  # Application title
  headerPanel(&quot;Reactivity&quot;),

  # Sidebar with controls to provide a caption, select a dataset, and 
  # specify the number of observations to view. Note that changes made
  # to the caption in the textInput control are updated in the output
  # area immediately as you type
  sidebarPanel(
    textInput(&quot;caption&quot;, &quot;Caption:&quot;, &quot;Data Summary&quot;),

    selectInput(&quot;dataset&quot;, &quot;Choose a dataset:&quot;, 
                choices = c(&quot;rock&quot;, &quot;pressure&quot;, &quot;cars&quot;)),

    numericInput(&quot;obs&quot;, &quot;Number of observations to view:&quot;, 10)
  ),


  # Show the caption, a summary of the dataset and an HTML table with
  # the requested number of observations
  mainPanel(
    h3(textOutput(&quot;caption&quot;)), 

    verbatimTextOutput(&quot;summary&quot;), 

    tableOutput(&quot;view&quot;)
  )
))</code></pre>
</div>
<h3 id='server_script'>Server Script</h3>

<p>The server script declares the <code>datasetInput</code> reactive expression as well as three reactive output values. There are detailed comments for each definition that describe how it works within the reactive system:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)
library(datasets)

# Define server logic required to summarize and view the selected dataset
shinyServer(function(input, output) {

  # By declaring datasetInput as a reactive expression we ensure that:
  #
  #  1) It is only called when the inputs it depends on changes
  #  2) The computation and result are shared by all the callers (it 
  #     only executes a single time)
  #  3) When the inputs change and the expression is re-executed, the
  #     new result is compared to the previous result; if the two are
  #     identical, then the callers are not notified
  #
  datasetInput &lt;- reactive({
    switch(input$dataset,
           &quot;rock&quot; = rock,
           &quot;pressure&quot; = pressure,
           &quot;cars&quot; = cars)
  })

  # The output$caption is computed based on a reactive expression that
  # returns input$caption. When the user changes the &quot;caption&quot; field:
  #
  #  1) This expression is automatically called to recompute the output 
  #  2) The new caption is pushed back to the browser for re-display
  # 
  # Note that because the data-oriented reactive expression below don't 
  # depend on input$caption, those expression are NOT called when 
  # input$caption changes.
  output$caption &lt;- renderText({
    input$caption
  })

  # The output$summary depends on the datasetInput reactive expression, 
  # so will be re-executed whenever datasetInput is re-executed 
  # (i.e. whenever the input$dataset changes)
  output$summary &lt;- renderPrint({
    dataset &lt;- datasetInput()
    summary(dataset)
  })

  # The output$view depends on both the databaseInput reactive expression
  # and input$obs, so will be re-executed whenever input$dataset or 
  # input$obs is changed. 
  output$view &lt;- renderTable({
    head(datasetInput(), n = input$obs)
  })
})</code></pre>
</div>
<p>We&#8217;ve reviewed a lot code and covered a lot of conceptual ground in the first three examples. The next section focuses on the mechanics of building a Shiny application from the ground up and also covers tips on how to run and debug Shiny applications.</p>
      

</div>


<!-- UI and Server -->
<div class="tab-pane" id="ui-and-server">


<h2 id='ui__server'>UI &amp; Server</h2>

<p>Let&#8217;s walk through the steps of building a simple Shiny application. A Shiny application is simply a directory containing a user-interface definition, a server script, and any additional data, scripts, or other resources required to support the application.</p>

<p>To get started building the application, create a new empty directory wherever you&#8217;d like, then create empty <code>ui.R</code> and <code>server.R</code> files within in. For purposes of illustration we&#8217;ll assume you&#8217;ve chosen to create the application at ~/shinyapp:</p>
<pre><code>~/shinyapp
|-- ui.R
|-- server.R
</code></pre>
<p>Now we&#8217;ll add the minimal code required in each source file. We&#8217;ll first define the user interface by calling the function <code>pageWithSidebar</code> and passing it&#8217;s result to the <code>shinyUI</code> function:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for miles per gallon application
shinyUI(pageWithSidebar(

  # Application title
  headerPanel(&quot;Miles Per Gallon&quot;),

  sidebarPanel(),

  mainPanel()
))</code></pre>
</div>
<p>The three functions <code>headerPanel</code>, <code>sidebarPanel</code>, and <code>mainPanel</code> define the various regions of the user-interface. The application will be called &#8220;Miles Per Gallon&#8221; so we specify that as the title when we create the header panel. The other panels are empty for now.</p>

<p>Now let&#8217;s define a skeletal server implementation. To do this we call <code>shinyServer</code> and pass it a function that accepts two parameters: <code>input</code> and <code>output</code>:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define server logic required to plot various variables against mpg
shinyServer(function(input, output) {

})</code></pre>
</div>
<p>Our server function is empty for now but later we&#8217;ll use it to define the relationship between our inputs and outputs.</p>

<p>We&#8217;ve now created the most minimal possible Shiny application. You can run the application by calling the <code>runApp</code> function as follows:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runApp(&quot;~/shinyapp&quot;)</code></pre>
</div>
<p>If everything is working correctly you&#8217;ll see the application appear in your browser looking something like this:</p>

<p><img alt='MPG Screenshot' src='screenshots/mpg-empty.png' /></p>

<p>We now have a running Shiny application however it doesn&#8217;t do much yet. In the next section we&#8217;ll complete the application by specifying the user-interface and implementing the server script.</p>

</div>

<!-- Inputs and Outputs -->
<div class="tab-pane" id="inputs-and-outputs">


<h2 id='inputs__outputs'>Inputs &amp; Outputs</h2>

<h3 id='adding_inputs_to_the_sidebar'>Adding Inputs to the Sidebar</h3>

<p>The application we&#8217;ll be building uses the mtcars data from the R datasets package, and allows users to see a box-plot that explores the relationship between miles-per-gallon (MPG) and three other variables (Cylinders, Transmission, and Gears).</p>

<p>We want to provide a way to select which variable to plot MPG against as well as provide an option to include or exclude outliers from the plot. To do this we&#8217;ll add two elements to the sidebar, a <code>selectInput</code> to specify the variable and a <code>checkboxInput</code> to control display of outliers. Our user-interface definition looks like this after adding these elements:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for miles per gallon application
shinyUI(pageWithSidebar(

  # Application title
  headerPanel(&quot;Miles Per Gallon&quot;),

  # Sidebar with controls to select the variable to plot against mpg
  # and to specify whether outliers should be included
  sidebarPanel(
    selectInput(&quot;variable&quot;, &quot;Variable:&quot;,
                list(&quot;Cylinders&quot; = &quot;cyl&quot;, 
                     &quot;Transmission&quot; = &quot;am&quot;, 
                     &quot;Gears&quot; = &quot;gear&quot;)),

    checkboxInput(&quot;outliers&quot;, &quot;Show outliers&quot;, FALSE)
  ),

  mainPanel()
))</code></pre>
</div>
<p>If you run the application again after making these changes you&#8217;ll see the two user-inputs we defined displayed within the sidebar:</p>

<p><img alt='MPG Screenshot' src='screenshots/mpg-with-inputs.png' /></p>

<h3 id='creating_the_server_script'>Creating the Server Script</h3>

<p>Next we need to define the server-side of the application which will accept inputs and compute outputs. Our server.R file is shown below, and illustrates some important concepts:</p>

<ul>
<li>Accessing input using slots on the <code>input</code> object and generating output by assigning to slots on the <code>output</code> object.</li>

<li>Initializing data at startup that can be accessed throughout the lifetime of the application.</li>

<li>Using a reactive expression to compute a value shared by more than one output.</li>
</ul>

<p>The basic task of a Shiny server script is to define the relationship between inputs and outputs. Our script does this by accessing inputs to perform computations and by assigning reactive expressions to output slots.</p>

<p>Here is the source code for the full server script (the inline comments explain the implementation technqiues in more detail):</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)
library(datasets)

# We tweak the &quot;am&quot; field to have nicer factor labels. Since this doesn't
# rely on any user inputs we can do this once at startup and then use the
# value throughout the lifetime of the application
mpgData &lt;- mtcars
mpgData$am &lt;- factor(mpgData$am, labels = c(&quot;Automatic&quot;, &quot;Manual&quot;))

# Define server logic required to plot various variables against mpg
shinyServer(function(input, output) {

  # Compute the forumla text in a reactive expression since it is 
  # shared by the output$caption and output$mpgPlot expressions
  formulaText &lt;- reactive({
    paste(&quot;mpg ~&quot;, input$variable)
  })

  # Return the formula text for printing as a caption
  output$caption &lt;- renderText({
    formulaText()
  })

  # Generate a plot of the requested variable against mpg and only 
  # include outliers if requested
  output$mpgPlot &lt;- renderPlot({
    boxplot(as.formula(formulaText()), 
            data = mpgData,
            outline = input$outliers)
  })
})</code></pre>
</div>
<p>The use of <code>renderText</code> and <code>renderPlot</code> to generate output (rather than just assigning values directly) is what makes the application reactive. These reactive wrappers return special expressions that are only re-executed when their dependencies change. This behavior is what enables Shiny to automatically update output whenever input changes.</p>

<h3 id='displaying_outputs'>Displaying Outputs</h3>

<p>The server script assigned two output values: <code>output$caption</code> and <code>output$mpgPlot</code>. To update our user interface to display the output we need to add some elements to the main UI panel.</p>

<p>In the updated user-interface definition below you can see that we&#8217;ve added the caption as an h3 element and filled in it&#8217;s value using the <code>textOutput</code> function, and also rendered the plot by calling the <code>plotOutput</code> function:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for miles per gallon application
shinyUI(pageWithSidebar(

  # Application title
  headerPanel(&quot;Miles Per Gallon&quot;),

  # Sidebar with controls to select the variable to plot against mpg
  # and to specify whether outliers should be included
  sidebarPanel(
    selectInput(&quot;variable&quot;, &quot;Variable:&quot;,
                list(&quot;Cylinders&quot; = &quot;cyl&quot;, 
                     &quot;Transmission&quot; = &quot;am&quot;, 
                     &quot;Gears&quot; = &quot;gear&quot;)),

    checkboxInput(&quot;outliers&quot;, &quot;Show outliers&quot;, FALSE)
  ),

  # Show the caption and plot of the requested variable against mpg
  mainPanel(
    h3(textOutput(&quot;caption&quot;)),

    plotOutput(&quot;mpgPlot&quot;)
  )
))</code></pre>
</div>
<p>Running the application now shows it in its final form including inputs and dynamically updating outputs:</p>

<p><img alt='MPG Screenshot' src='screenshots/mpg-with-outputs.png' /></p>

<p>Now that we&#8217;ve got a simple application running we&#8217;ll probably want to make some changes. The next topic covers the basic cycle of editing, running, and debugging Shiny applications.</p>

</div>

<!-- Edit, Run, Debug -->
<div class="tab-pane" id="run-and-debug">


<h2 id='run__debug'>Run &amp; Debug</h2>

<p>Throughout the tutorial you&#8217;ve been calling <code>runApp</code> to run the example applications. This function starts the application and opens up your default web browser to view it. The call is blocking, meaning that it prevents traditional interaction with the console while the applciation is running.</p>

<p>To stop the application you simply interupt R &#8211; you can do this by pressing the Escape key in all R front ends as well as by clicking the stop button if your R environment provides one.</p>

<h3 id='running_in_a_separate_process'>Running in a Separate Process</h3>

<p>If you don&#8217;t want to block access to the console while running your Shiny application you can also run it in a separate process. You can do this by opening a terminal or console window and executing the following:</p>
<div>
  <pre><code class='console'>R -e &quot;shiny::runApp('~/shinyapp')&quot;</code></pre>
</div>
<p>By default <code>runApp</code> starts the application on port 8100. If you are using this default then you can connect to the running application by navigating your browser to <a href='http://localhost:8100'>http://localhost:8100</a>.</p>

<p>Note that below we discuss some techniques for debugging Shiny applications, including the ability to stop execution and inspect the current environment. In order to combine these techniques with running your applications in a separate terminal session you need to run R interactively (that is, first type &#8220;R&#8221; to start an R session then execute <code>runApp</code> from within the session).</p>

<h3 id='live_reloading'>Live Reloading</h3>

<p>When you make changes to your underlying user-interface definition or server script you don&#8217;t need to stop and restart your application to see the changes. Simply save your changes and then reload the browser to see the updated application in action.</p>

<p>One qualification to this: when a browser reload occurs Shiny explicitly checks the timestamps of the ui.R and server.R files to see if they need to be re-sourced. If you have other scripts or data files that change Shiny isn&#8217;t aware of those, so a full stop and restart of the application is necessary to see those changes reflected.</p>

<h3 id='debugging_techniques'>Debugging Techniques</h3>

<h4 id='printing'>Printing</h4>

<p>There are several techniques available for debugging Shiny applications. The first is to add calls to the <a href='http://stat.ethz.ch/R-manual/R-devel/library/base/html/cat.html'>cat</a> function which print diagnostics where appropriate. For example, these two calls to cat print diagnostics to standard output and standard error respectively:</p>
<div>
  <pre><code class='r'>cat(&quot;foo\n&quot;)
cat(&quot;bar\n&quot;, file=stderr())</code></pre>
</div>
<h4 id='using_browser'>Using browser</h4>

<p>The second technique is to add explicit calls to the <a href='http://stat.ethz.ch/R-manual/R-devel/library/base/html/browser.html'>browser</a> function to interrupt execution and inspect the environment where browser was called from. Note that using browser requires that you start the application from an interactive session (as opposed to using R -e as described above).</p>

<p>For example, to unconditionally stop execution at a certain point in the code:</p>
<div>
  <pre><code class='r'># Always stop execution here
browser()</code></pre>
</div>
<p>You can also use this technique to stop only on certain conditions. For example, to stop the MPG application only when the user selects &#8220;Transmission&#8221; as the variable:</p>
<div>
  <pre><code class='r'># Stop execution when the user selects &quot;am&quot;
browser(expr = identical(input$variable, &quot;am&quot;))</code></pre>
</div>
<h4 id='establishing_a_custom_error_handler'>Establishing a custom error handler</h4>

<p>You can also set the R &#34;error&#34; option to automatically enter the browser when an error occurs:</p>
<div>
  <pre><code class='r'># Immediately enter the browser when an error occurs
options(error = browser)</code></pre>
</div>
<p>Alternatively, you can specify the <a href='http://stat.ethz.ch/R-manual/R-devel/library/utils/html/recover.html'>recover</a> function as your error handler, which will print a list of the call stack and allow you to browse at any point in he stack:</p>
<div>
  <pre><code class='r'># Call the recover function when an error occurs
options(error = recover)</code></pre>
</div>
<p>If you want to set the error option automatically for every R session, you can do this in your .Rprofile file as described in this article on <a href='http://stat.ethz.ch/R-manual/R-patched/library/base/html/Startup.html'>R Startup</a>.</p>

</div>

<!-- Sliders -->
<div class="tab-pane" id="sliders">


<p><img alt='Sliders Screenshot' src='screenshots/sliders.png' /></p>

<p>The Sliders application demonstrates the many capabilities of slider controls, including the ability to run an animation sequence. To run the example type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;05_sliders&quot;)</code></pre>
</div>
<h3 id='customizing_sliders'>Customizing Sliders</h3>

<p>Shiny slider controls are extremely capable and customizable. Features supported include:</p>

<ul>
<li>The ability to input both single values and ranges</li>

<li>Custom formats for value display (e.g for currency)</li>

<li>The ability to animate the slider across a range of values</li>
</ul>

<p>Slider controls are created by calling the <code>sliderInput</code> function. The ui.R file demonstrates using sliders with a variety of options:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for slider demo application
shinyUI(pageWithSidebar(

  #  Application title
  headerPanel(&quot;Sliders&quot;),

  # Sidebar with sliders that demonstrate various available options
  sidebarPanel(
    # Simple integer interval
    sliderInput(&quot;integer&quot;, &quot;Integer:&quot;, 
                min=0, max=1000, value=500),

    # Decimal interval with step value
    sliderInput(&quot;decimal&quot;, &quot;Decimal:&quot;, 
                min = 0, max = 1, value = 0.5, step= 0.1),

    # Specification of range within an interval
    sliderInput(&quot;range&quot;, &quot;Range:&quot;,
                min = 1, max = 1000, value = c(200,500)),

    # Provide a custom currency format for value display, with basic animation
    sliderInput(&quot;format&quot;, &quot;Custom Format:&quot;, 
                min = 0, max = 10000, value = 0, step = 2500,
                format=&quot;$#,##0&quot;, locale=&quot;us&quot;, animate=TRUE),

    # Animation with custom interval (in ms) to control speed, plus looping
    sliderInput(&quot;animation&quot;, &quot;Looping Animation:&quot;, 1, 2000, 1, step = 10, 
                animate=animationOptions(interval=300, loop=T))
  ),

  # Show a table summarizing the values entered
  mainPanel(
    tableOutput(&quot;values&quot;)
  )
))</code></pre>
</div>
<h3 id='server_script'>Server Script</h3>

<p>The server side of the Slider application is very straightforward: it creates a data frame containing all of the input values and then renders it as an HTML table:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define server logic for slider examples
shinyServer(function(input, output) {

  # Reactive expression to compose a data frame containing all of the values
  sliderValues &lt;- reactive({

    # Compose data frame
    data.frame(
      Name = c(&quot;Integer&quot;, 
               &quot;Decimal&quot;,
               &quot;Range&quot;,
               &quot;Custom Format&quot;,
               &quot;Animation&quot;),
      Value = as.character(c(input$integer, 
                             input$decimal,
                             paste(input$range, collapse=' '),
                             input$format,
                             input$animation)), 
      stringsAsFactors=FALSE)
  }) 

  # Show the values using an HTML table
  output$values &lt;- renderTable({
    sliderValues()
  })
})</code></pre>
</div>

</div>


<!-- Tabsets -->
<div class="tab-pane" id="tabsets">


<p><img alt='Tabsets Screenshot' src='screenshots/tabsets.png' /></p>

<p>The Tabsets application demonstrates using tabs to organize output. To run the example type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;06_tabsets&quot;)</code></pre>
</div>
<h3 id='tab_panels'>Tab Panels</h3>

<p>Tabsets are created by calling the <code>tabsetPanel</code> function with a list of tabs created by the <code>tabPanel</code> function. Each tab panel is provided a list of output elements which are rendered vertically within the tab.</p>

<p>In this example we updated our Hello Shiny application to add a summary and table view of the data, each rendered on their own tab. Here is the revised source code for the user-interface:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for random distribution application 
shinyUI(pageWithSidebar(

  # Application title
  headerPanel(&quot;Tabsets&quot;),

  # Sidebar with controls to select the random distribution type
  # and number of observations to generate. Note the use of the br()
  # element to introduce extra vertical spacing
  sidebarPanel(
    radioButtons(&quot;dist&quot;, &quot;Distribution type:&quot;,
                 list(&quot;Normal&quot; = &quot;norm&quot;,
                      &quot;Uniform&quot; = &quot;unif&quot;,
                      &quot;Log-normal&quot; = &quot;lnorm&quot;,
                      &quot;Exponential&quot; = &quot;exp&quot;)),
    br(),

    sliderInput(&quot;n&quot;, 
                &quot;Number of observations:&quot;, 
                 value = 500,
                 min = 1, 
                 max = 1000)
  ),

  # Show a tabset that includes a plot, summary, and table view
  # of the generated distribution
  mainPanel(
    tabsetPanel(
      tabPanel(&quot;Plot&quot;, plotOutput(&quot;plot&quot;)), 
      tabPanel(&quot;Summary&quot;, verbatimTextOutput(&quot;summary&quot;)), 
      tabPanel(&quot;Table&quot;, tableOutput(&quot;table&quot;))
    )
  )
))</code></pre>
</div>
<h3 id='tabs_and_reactive_data'>Tabs and Reactive Data</h3>

<p>Introducing tabs into our user-interface underlines the importance of creating reactive expressions for shared data. In this example each tab provides its own view of the dataset. If the dataset is expensive to compute then our user-interface might be quite slow to render. The server script below demonstrates how to calculate the data once in a reactive expression and have the result be shared by all of the output tabs:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define server logic for random distribution application
shinyServer(function(input, output) {

  # Reactive expression to generate the requested distribution. This is 
  # called whenever the inputs change. The renderers defined 
  # below then all use the value computed from this expression
  data &lt;- reactive({  
    dist &lt;- switch(input$dist,
                   norm = rnorm,
                   unif = runif,
                   lnorm = rlnorm,
                   exp = rexp,
                   rnorm)

    dist(input$n)
  })

  # Generate a plot of the data. Also uses the inputs to build the 
  # plot label. Note that the dependencies on both the inputs and
  # the 'data' reactive expression are both tracked, and all expressions 
  # are called in the sequence implied by the dependency graph
  output$plot &lt;- renderPlot({
    dist &lt;- input$dist
    n &lt;- input$n

    hist(data(), 
         main=paste('r', dist, '(', n, ')', sep=''))
  })

  # Generate a summary of the data
  output$summary &lt;- renderPrint({
    summary(data())
  })

  # Generate an HTML table view of the data
  output$table &lt;- renderTable({
    data.frame(x=data())
  })
})</code></pre>
</div>


</div>

<!-- More Widgets -->
<div class="tab-pane" id="more-widgets">


<p><img alt='More Widgets Screenshot' src='screenshots/more-widgets.png' /></p>

<p>The More Widgets application demonstrates the help text and submit button widgets as well as the use of embedded HTML elements to customize formatting. To run the example type:</p>
<div>
  <pre><code class='r'>&gt; library(shiny)
&gt; runExample(&quot;07_widgets&quot;)</code></pre>
</div>
<h3 id='ui_enhancements'>UI Enhancements</h3>

<p>In this example we update the Shiny Text application with some additional controls and formatting, specifically:</p>

<ul>
<li>We added a <code>helpText</code> control to provide additional clarifying text alongside our input controls.</li>

<li>We added a <code>submitButton</code> control to indicate that we don&#8217;t want a live connection between inputs and outputs, but rather to wait until the user clicks that button to update the output. This is especially useful if computing output is computationally expensive.</li>

<li>We added <code>h4</code> elements (heading level 4) into the output pane. Shiny offers a variety of functions for including HTML elements directly in pages including headings, paragraphics, links, and more.</li>
</ul>

<p>Here is the updated source code for the user-interface:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define UI for dataset viewer application
shinyUI(pageWithSidebar(

  # Application title.
  headerPanel(&quot;More Widgets&quot;),

  # Sidebar with controls to select a dataset and specify the number
  # of observations to view. The helpText function is also used to 
  # include clarifying text. Most notably, the inclusion of a 
  # submitButton defers the rendering of output until the user 
  # explicitly clicks the button (rather than doing it immediately
  # when inputs change). This is useful if the computations required
  # to render output are inordinately time-consuming.
  sidebarPanel(
    selectInput(&quot;dataset&quot;, &quot;Choose a dataset:&quot;, 
                choices = c(&quot;rock&quot;, &quot;pressure&quot;, &quot;cars&quot;)),

    numericInput(&quot;obs&quot;, &quot;Number of observations to view:&quot;, 10),

    helpText(&quot;Note: while the data view will show only the specified&quot;,
             &quot;number of observations, the summary will still be based&quot;,
             &quot;on the full dataset.&quot;),

    submitButton(&quot;Update View&quot;)
  ),

  # Show a summary of the dataset and an HTML table with the requested
  # number of observations. Note the use of the h4 function to provide
  # an additional header above each output section.
  mainPanel(
    h4(&quot;Summary&quot;),
    verbatimTextOutput(&quot;summary&quot;),

    h4(&quot;Observations&quot;),
    tableOutput(&quot;view&quot;)
  )
))</code></pre>
</div>
<h3 id='server_script'>Server Script</h3>

<p>All of the changes from the original Shiny Text application were to the user-interface, the server script remains the same:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)
library(datasets)

# Define server logic required to summarize and view the selected dataset
shinyServer(function(input, output) {

  # Return the requested dataset
  datasetInput &lt;- reactive({
    switch(input$dataset,
           &quot;rock&quot; = rock,
           &quot;pressure&quot; = pressure,
           &quot;cars&quot; = cars)
  })

  # Generate a summary of the dataset
  output$summary &lt;- renderPrint({
    dataset &lt;- datasetInput()
    summary(dataset)
  })

  # Show the first &quot;n&quot; observations
  output$view &lt;- renderTable({
    head(datasetInput(), n = input$obs)
  })
})</code></pre>
</div>

</div>

<!-- Uploading Data -->
<div class="tab-pane" id="uploads">


<p><img alt='Uploading Files Screenshot' src='screenshots/uploads.png' /></p>

<p>Sometimes you&#8217;ll want users to be able to upload their own data to your application. Shiny makes it easy to offer your users file uploads straight from the browser, which you can then access from your server logic.</p>

<p><strong>Important notes:</strong></p>

<ul>
<li>This feature does not work with Internet Explorer 9 and earlier (not even with Shiny Server).</li>

<li>By default, Shiny limits file uploads to 5MB per file. You can modify this limit by using the <code>shiny.maxRequestSize</code> option. For example, adding <code>options(shiny.maxRequestSize=30*1024^2)</code> to the top of <code>server.R</code> would increase the limit to 30MB.</li>
</ul>

<p>To run this example, type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;09_upload&quot;)</code></pre>
</div>
<p>File upload controls are created by using the <code>fileInput</code> function in your <code>ui.R</code> file. You access the uploaded data similarly to other types of input: by referring to <code>input$<i>inputId</i></code>. The <code>fileInput</code> function takes a <code>multiple</code> parameter that can be set to <code>TRUE</code> to allow the user to select multiple files, and an <code>accept</code> parameter can be used to give the user clues as to what kind of files the application expects.</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>shinyUI(pageWithSidebar(
  headerPanel(&quot;CSV Viewer&quot;),
  sidebarPanel(
    fileInput('file1', 'Choose CSV File',
              accept=c('text/csv', 'text/comma-separated-values,text/plain')),
    tags$hr(),
    checkboxInput('header', 'Header', TRUE),
    radioButtons('sep', 'Separator',
                 c(Comma=',',
                   Semicolon=';',
                   Tab='\t'),
                 'Comma'),
    radioButtons('quote', 'Quote',
                 c(None='',
                   'Double Quote'='&quot;',
                   'Single Quote'=&quot;'&quot;),
                 'Double Quote')
  ),
  mainPanel(
    tableOutput('contents')
  )
))</code></pre>
</div>
<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  output$contents &lt;- renderTable({
    
    # input$file1 will be NULL initially. After the user selects and uploads a 
    # file, it will be a data frame with 'name', 'size', 'type', and 'datapath' 
    # columns. The 'datapath' column will contain the local filenames where the 
    # data can be found.

    inFile &lt;- input$file1

    if (is.null(inFile))
      return(NULL)
    
    read.csv(inFile$datapath, header=input$header, sep=input$sep, quote=input$quote)
  })
})</code></pre>
</div>
<p>This example receives a file and attempts to read it as comma-separated values using <code>read.csv</code>, then displays the results in a table. As the comment in <code>server.R</code> indicates, <code>inFile</code> is either <code>NULL</code> or a dataframe that contains one row per uploaded file. In this case, <code>fileInput</code> did not have the <code>multiple</code> parameter so we can assume there is only one row.</p>

<p>The file contents can be accessed by reading the file named by the <code>datapath</code> column. See the <code>?fileInput</code> help topic to learn more about the other columns that are available.</p>

</div>

<!-- Downloading Data -->
<div class="tab-pane" id="downloads">


<p><img alt='Downloading Data Screenshot' src='screenshots/downloads.png' /></p>

<p>The examples so far have demonstrated outputs that appear directly in the page, such as plots, tables, and text boxes. Shiny also has the ability to offer file downloads that are calculated on the fly, which makes it easy to build data exporting features.</p>

<p>To run the example below, type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;10_download&quot;)</code></pre>
</div>
<p>You define a download using the <code>downloadHandler</code> function on the server side, and either <code>downloadButton</code> or <code>downloadLink</code> in the UI:</p>

<h4 id='uir'>ui.R</h4>
<div>
  <pre><code class='r'>shinyUI(pageWithSidebar(
  headerPanel('Download Example'),
  sidebarPanel(
    selectInput(&quot;dataset&quot;, &quot;Choose a dataset:&quot;, 
                choices = c(&quot;rock&quot;, &quot;pressure&quot;, &quot;cars&quot;)),
    downloadButton('downloadData', 'Download')
  ),
  mainPanel(
    tableOutput('table')
  )
))</code></pre>
</div>
<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  datasetInput &lt;- reactive({
    switch(input$dataset,
           &quot;rock&quot; = rock,
           &quot;pressure&quot; = pressure,
           &quot;cars&quot; = cars)
  })
  
  output$table &lt;- renderTable({
    datasetInput()
  })
  
  output$downloadData &lt;- downloadHandler(
    filename = function() { paste(input$dataset, '.csv', sep='') },
    content = function(file) {
      write.csv(datasetInput(), file)
    }
  )
})</code></pre>
</div>
<p>As you can see, <code>downloadHandler</code> takes a <code>filename</code> argument, which tells the web browser what filename to default to when saving. This argument can either be a simple string, or it can be a function that returns a string (as is the case here).</p>

<p>The <code>content</code> argument must be a function that takes a single argument, the file name of a non-existent temp file. The <code>content</code> function is responsible for writing the contents of the file download into that temp file.</p>

<p>Both the <code>filename</code> and <code>content</code> arguments can use reactive values and expressions (although in the case of <code>filename</code>, be sure your argument is an actual function; <code>filename = paste(input$dataset, &#39;.csv&#39;)</code> is not going to work the way you want it to, since it is evaluated only once, when the download handler is being defined).</p>

<p>Generally, those are the only two arguments you&#8217;ll need. There is an optional <code>contentType</code> argument; if it is <code>NA</code> or <code>NULL</code>, Shiny will attempt to guess the appropriate value based on the filename. Provide your own content type string (e.g. <code>&quot;text/plain&quot;</code>) if you want to override this behavior.</p>

</div>

<!-- Dynamic UI -->
<div class="tab-pane" id="dynamic-ui">


<h2 id='dynamic_ui'>Dynamic UI</h2>

<p>Shiny apps are often more than just a fixed set of controls that affect a fixed set of outputs. Inputs may need to be shown or hidden depending on the state of another input, or input controls may need to be created on-the-fly in response to user input.</p>

<p>Shiny currently has three different approaches you can use to make your interfaces more dynamic. From easiest to most difficult, they are:</p>

<ul>
<li><strong>The <code>conditionalPanel</code> function</strong>, which is used in <code>ui.R</code> and wraps a set of UI elements that need to be dynamically shown/hidden</li>

<li><strong>The <code>renderUI</code> function</strong>, which is used in <code>server.R</code> in conjunction with the <code>htmlOutput</code> function in <code>ui.R</code>, lets you generate calls to UI functions and make the results appear in a predetermined place in the UI</li>

<li><strong>Use JavaScript</strong> to modify the webpage directly.</li>
</ul>

<p>Let&#8217;s take a closer look at each approach.</p>

<h3 id='showing_and_hiding_controls_with_'>Showing and Hiding Controls With <tt>conditionalPanel</tt></h3>

<p><code>conditionalPanel</code> creates a panel that shows and hides its contents depending on the value of a JavaScript expression. Even if you don&#8217;t know any JavaScript, simple comparison or equality operations are extremely easy to do, as they look a lot like R (and many other programming languages).</p>

<p>Here&#8217;s an example for adding an optional smoother to a ggplot, and choosing its smoothing method:</p>
<pre><code class='r'># Partial example
checkboxInput("smooth", "Smooth"),
conditionalPanel(
  condition = "input.smooth == true",
  selectInput("smoothMethod", "Method",
              list("lm", "glm", "gam", "loess", "rlm"))
)</code></pre>
<p>In this example, the select control for <code>smoothMethod</code> will appear only when the <code>smooth</code> checkbox is checked. Its condition is <code>&quot;input.smooth == true&quot;</code>, which is a JavaScript expression that will be evaluated whenever any inputs/outputs change.</p>

<p>The condition can also use <code>output</code> values; they work in the same way (<code>output.foo</code> gives you the value of the output <code>foo</code>). If you have a situation where you wish you could use an R expression as your <code>condition</code> argument, you can create a reactive expression in <code>server.R</code> and assign it to a new output, then refer to that output in your <code>condition</code> expression. For example:</p>

<h4 id='uir'>ui.R</h4>
<pre><code class='r'># Partial example
selectInput("dataset", "Dataset", c("diamonds", "rock", "pressure", "cars")),
conditionalPanel(
  condition = "output.nrows",
  checkboxInput("headonly", "Only use first 1000 rows"))</code></pre>
<h4 id='serverr'>server.R</h4>
<pre><code class='r'># Partial example
datasetInput &lt;- reactive({
   switch(input$dataset,
          "rock" = rock,
          "pressure" = pressure,
          "cars" = cars)
})

output$nrows &lt;- reactive({
  nrow(datasetInput())
})</code></pre>
<p>However, since this technique requires server-side calculation (which could take a long time, depending on what other reactive expressions are executing) we recommend that you avoid using <code>output</code> in your conditions unless absolutely necessary.</p>

<h3 id='creating_controls_on_the_fly_with_'>Creating Controls On the Fly With <tt>renderUI</tt></h3>

<p><em>Note: This feature should be considered experimental. Let us know whether you find it useful.</em></p>

<p>Sometimes it&#8217;s just not enough to show and hide a fixed set of controls. Imagine prompting the user for a latitude/longitude, then allowing the user to select from a checklist of cities within a certain radius. In this case, you can use the <code>renderUI</code> expression to dynamically create controls based on the user&#8217;s input.</p>

<h4 id='uir'>ui.R</h4>
<pre><code class='r'># Partial example
numericInput("lat", "Latitude"),
numericInput("long", "Longitude"),
uiOutput("cityControls")</code></pre>
<h4 id='serverr'>server.R</h4>
<pre><code class='r'># Partial example
output$cityControls &lt;- renderUI({
  cities &lt;- getNearestCities(input$lat, input$long)
  checkboxGroupInput("cities", "Choose Cities", cities)
})</code></pre>
<p><code>renderUI</code> works just like <code>renderPlot</code>, <code>renderText</code>, and the other output rendering functions you&#8217;ve seen before, but it expects the expression it wraps to return an HTML tag (or a list of HTML tags, using <code>tagList</code>). These tags can include inputs and outputs.</p>

<p>In <code>ui.R</code>, use a <code>uiOutput</code> to tell Shiny where these controls should be rendered.</p>

<h3 id='use_javascript_to_modify_the_page'>Use JavaScript to Modify the Page</h3>

<p><em>Note: This feature should be considered experimental. Let us know whether you find it useful.</em></p>

<p>You can use JavaScript/jQuery to modify the page directly. General instructions for doing so are outside the scope of this tutorial, except to mention an important additional requirement. Each time you add new inputs/outputs to the DOM, or remove existing inputs/outputs from the DOM, you need to tell Shiny. Our current recommendation is:</p>

<ul>
<li>Before making changes to the DOM that may include adding or removing Shiny inputs or outputs, call <code>Shiny.unbindAll()</code>.</li>

<li>After such changes, call <code>Shiny.bindAll()</code>.</li>
</ul>

<p>If you are adding or removing many inputs/outputs at once, it&#8217;s fine to call <code>Shiny.unbindAll()</code> once at the beginning and <code>Shiny.bindAll()</code> at the end&#160;&#8211; it&#8217;s not necessary to put these calls around each individual addition or removal of inputs/outputs.</p>

</div>

<!-- HTML UI -->
<div class="tab-pane" id="html-ui">


<p><img alt='HTML UI Screenshot' src='screenshots/html-ui.png' /></p>

<p>The HTML UI application demonstrates defining a Shiny user-interface using a standard HTML page rather than a ui.R script. To run the example type:</p>
<div>
  <pre><code class='console'>&gt; library(shiny)
&gt; runExample(&quot;08_html&quot;)</code></pre>
</div>
<h3 id='defining_an_html_ui'>Defining an HTML UI</h3>

<p>The previous examples in this tutorial used a ui.R file to build their user-interfaces. While this is a fast and convenient way to build user-interfaces, some appliations will inevitably require more flexiblity. For this type of application, you can define your user-interface directly in HTML. In this case there is no ui.R file and the directory structure looks like this:</p>
<pre><code>&lt;<em>application-dir</em>&gt;
|-- www
    |-- index.html
|-- server.R
</code></pre>
<p>In this example we re-write the front-end of the Tabsets application using HTML directly. Here is the source code for the new user-interface definition:</p>

<h4 id='wwwindexhtml'>www/index.html</h4>
<pre style='color:#000000;background:#ffffff;'><code><span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>html</span><span style='color:#7f0055; '>></span>

<span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>head</span><span style='color:#7f0055; '>></span>
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>script src="shared/jquery.js" type="text/javascript"</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>script</span><span style='color:#7f0055; '>></span>
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>script src="shared/shiny.js" type="text/javascript"</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>script</span><span style='color:#7f0055; '>></span>
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>link</span> rel=<span style='color:#2a00ff; '>"stylesheet"</span> type=<span style='color:#2a00ff; '>"text/css"</span> href=<span style='color:#2a00ff; '>"shared/shiny.css"</span><span style='color:#7f0055; '>/></span> 
<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>head</span><span style='color:#7f0055; '>></span>
 
<span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>body</span><span style='color:#7f0055; '>></span>
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>h1</span><span style='color:#7f0055; '>></span>HTML UI<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>h1</span><span style='color:#7f0055; '>></span>
 
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>p</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>label</span><span style='color:#7f0055; '>></span>Distribution type:<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>label</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>br</span> <span style='color:#7f0055; '>/></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>select</span> name=<span style='color:#2a00ff; '>"dist"</span><span style='color:#7f0055; '>></span>
      <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>option</span> value=<span style='color:#2a00ff; '>"norm"</span><span style='color:#7f0055; '>></span>Normal<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>option</span><span style='color:#7f0055; '>></span>
      <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>option</span> value=<span style='color:#2a00ff; '>"unif"</span><span style='color:#7f0055; '>></span>Uniform<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>option</span><span style='color:#7f0055; '>></span>
      <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>option</span> value=<span style='color:#2a00ff; '>"lnorm"</span><span style='color:#7f0055; '>></span>Log-normal<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>option</span><span style='color:#7f0055; '>></span>
      <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>option</span> value=<span style='color:#2a00ff; '>"exp"</span><span style='color:#7f0055; '>></span>Exponential<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>option</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>select</span><span style='color:#7f0055; '>></span> 
  <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>p</span><span style='color:#7f0055; '>></span>
 
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>p</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>label</span><span style='color:#7f0055; '>></span>Number of observations:<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>label</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>br</span> <span style='color:#7f0055; '>/></span> 
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>input</span> type=<span style='color:#2a00ff; '>"number"</span> name=<span style='color:#2a00ff; '>"n"</span> value=<span style='color:#2a00ff; '>"500"</span> min=<span style='color:#2a00ff; '>"1"</span> max=<span style='color:#2a00ff; '>"1000"</span> <span style='color:#7f0055; '>/></span>
  <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>p</span><span style='color:#7f0055; '>></span>
 
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>pre</span> id=<span style='color:#2a00ff; '>"summary"</span> class=<span style='color:#2a00ff; '>"shiny-text-output"</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>pre</span><span style='color:#7f0055; '>></span> 
  
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"plot"</span> class=<span style='color:#2a00ff; '>"shiny-plot-output"</span> 
       style=<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; font-weight:bold; '>width</span>: 100%; <span style='color:#7f0055; font-weight:bold; '>height</span>: 400px<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span> 
  
  <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"table"</span> class=<span style='color:#2a00ff; '>"shiny-html-output"</span><span style='color:#7f0055; '>></span><span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span>
<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>body</span><span style='color:#7f0055; '>></span>

<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>html</span><span style='color:#7f0055; '>></span>
</code></pre>
<p>There are few things to point out regarding how Shiny binds HTML elements back to inputs and outputs:</p>

<ul>
<li>HTML form elmements (in this case a select list and a number input) are bound to input slots using their <code>name</code> attribute.</li>

<li>Output is rendered into HTML elements based on matching their <code>id</code> attribute to an output slot and by specifying the requisite css class for the element (in this case either shiny-text-output, shiny-plot-output, or shiny-html-output).</li>
</ul>

<p>With this technique you can create highly customized user-interfaces using whatever HTML, CSS, and JavaScript you like.</p>

<h3 id='server_script'>Server Script</h3>

<p>All of the changes from the original Tabsets application were to the user-interface, the server script remains the same:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>library(shiny)

# Define server logic for random distribution application
shinyServer(function(input, output) {

  # Reactive expression to generate the requested distribution. This is 
  # called whenever the inputs change. The output renderers defined 
  # below then all used the value computed from this expression
  data &lt;- reactive({  
    dist &lt;- switch(input$dist,
                   norm = rnorm,
                   unif = runif,
                   lnorm = rlnorm,
                   exp = rexp,
                   rnorm)

    dist(input$n)
  })

  # Generate a plot of the data. Also uses the inputs to build the 
  # plot label. Note that the dependencies on both the inputs and
  # the data reactive expression are both tracked, and all expressions 
  # are called in the sequence implied by the dependency graph
  output$plot &lt;- renderPlot({
    dist &lt;- input$dist
    n &lt;- input$n

    hist(data(), 
         main=paste('r', dist, '(', n, ')', sep=''))
  })

  # Generate a summary of the data
  output$summary &lt;- renderPrint({
    summary(data())
  })

  # Generate an HTML table view of the data
  output$table &lt;- renderTable({
    data.frame(x=data())
  })
})</code></pre>
</div>

</div>

<!-- Scoping -->
<div class="tab-pane" id="scoping">


<h2 id='scoping'>Scoping</h2>

<p>Where you define objects will determine where the objects are visible. There are three different levels of visibility that you&#8217;ll want to be aware of when writing Shiny apps. Some objects are visible within the <code>server.R</code> code of each user session; other objects are visible in the <code>server.R</code> code across all sessions (multiple users could use a shared variable); and yet others are visible in the <code>server.R</code> and the <code>ui.R</code> code across all user sessions.</p>

<h3 id='persession_objects'>Per-session objects</h3>

<p>In <code>server.R</code>, when you call <code>shinyServer()</code>, you pass it a function <code>func</code> which takes two arguments, <code>input</code> and <code>output</code>:</p>
<div>
  <pre><code class='r'>shinyServer(func = function(input, output) {
  # Server code here
  # ...
})</code></pre>
</div>
<p>The function that you pass to <code>shinyServer()</code> is called once for each session. In other words, <code>func</code> is called each time a web browser is pointed to the Shiny application.</p>

<p>Everything within this function is instantiated separately for each session. This includes the <code>input</code> and <code>output</code> objects that are passed to it: each session has its own <code>input</code> and <code>output</code> objects, visible within this function.</p>

<p>Other objects inside the function, such as variables and functions, are also instantiated for each session. In this example, each session will have its own variable named <code>startTime</code>, which records the start time for the session:</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  startTime &lt;- Sys.time()

  # ...
})</code></pre>
</div>
<h3 id='objects_visible_across_all_sessions'>Objects visible across all sessions</h3>

<p>You might want some objects to be visible across all sessions. For example, if you have large data structures, or if you have utility functions that are not reactive (ones that don&#8217;t involve the <code>input</code> or <code>output</code> objects), then you can create these objects once and share them across all user sessions, by placing them in <code>server.R</code>, but outside of the call to <code>shinyServer()</code>.</p>

<p>For example:</p>
<div>
  <pre><code class='r'># A read-only data set that will load once, when Shiny starts, and will be
# available to each user session
bigDataSet &lt;- read.csv('bigdata.csv')

# A non-reactive function that will be available to each user session
utilityFunction &lt;- function(x) {
  # Function code here
  # ...
}

shinyServer(function(input, output) {
  # Server code here
  # ...
})</code></pre>
</div>
<p>You could put <code>bigDataSet</code> and <code>utilityFunction</code> inside of the function passed to <code>shinyServer()</code>, but doing so will be less efficient, because they will be created each time a user connects.</p>

<p>If the objects change, then the changed objects will be visible in every user session. But note that you would need to use the <code>&lt;&lt;-</code> assignment operator to change <code>bigDataSet</code>, because the <code>&lt;-</code> operator only assigns values in the local environment.</p>
<div>
  <pre><code class='r'>varA &lt;- 1
varB &lt;- 1
listA &lt;- list(X=1, Y=2)
listB &lt;- list(X=1, Y=2)

shinyServer(function(input, output) {
  # Create a local variable varA, which will be a copy of the shared variable
  # varA plus 1. This local copy of varA is not be visible in other sessions.
  varA &lt;- varA + 1

  # Modify the shared variable varB. It will be visible in other sessions.
  varB &lt;&lt;- varB + 1

  # Makes a local copy of listA
  listA$X &lt;- 5

  # Modify the shared copy of listB
  listB$X &lt;&lt;- 5

  # ...
})</code></pre>
</div>
<p>Things work this way because <code>server.R</code> is sourced when you start your Shiny app. Everything in the script is run immediately, including the call to <code>shinyServer()</code>&#8212;but the function which is passed to <code>shinyServer()</code> is called only when a web browser connects and a new session is started.</p>

<h3 id='global_objects'>Global objects</h3>

<p>Objects defined in <code>global.R</code> are similar to those defined in <code>server.R</code> outside <code>shinyServer()</code>, with one important difference: they are also visible to the code in <code>ui.R</code>. This is because they are loaded into the global environment of the R session; all R code in a Shiny app is run in the global environment or a child of it.</p>

<p>In practice, there aren&#8217;t many times where it&#8217;s necessary to share variables between <code>server.R</code> and <code>ui.R</code>. The code in <code>ui.R</code> is run once, when the Shiny app is started and it generates an HTML file which is cached and sent to each web browser that connects. This may be useful for setting some shared configuration options.</p>

<h3 id='scope_for_included_r_files'>Scope for included R files</h3>

<p>If you want to split the server or ui code into multiple files, you can use <code>source(local=TRUE)</code> to load each file. You can think of this as putting the code in-line, so the code from the sourced files will receive the same scope as if you copied and pasted the text right there.</p>

<p>This example <code>server.R</code> file shows how sourced files will be scoped:</p>
<div>
  <pre><code class='r'># Objects in this file are shared across all sessions
source('all_sessions.R', local=TRUE)

shinyServer(function(input, output) {
  # Objects in this file are defined in each session
  source('each_session.R', local=TRUE)

  output$text &lt;- renderText({
    # Objects in this file are defined each time this function is called
    source('each_call.R', local=TRUE)

    # ...
  })
})</code></pre>
</div>
<p>If you use the default value of <code>local=FALSE</code>, then the file will be sourced in the global environment.</p>

</div>

<!-- Client Data -->
<div class="tab-pane" id="client-data">


<h2 id='getting_noninput_data_from_the_client'>Getting Non-Input Data From the Client</h2>

<p>On the server side, Shiny applications use the <code>input</code> object to receive user input from the client web browser. The values in <code>input</code> are set by UI objects on the client web page. There are also non-input values (in the sense that the user doesn&#8217;t enter these values through UI components) that are stored in an object called <code>session$clientData</code>. These values include the URL, the pixel ratio (for high-resolution &#8220;Retina&#8221; displays), the hidden state of output objects, and the height and width of plot outputs.</p>

<h3 id='using_sessionclientdata'>Using session$clientData</h3>

<p>To access <code>session$clientData</code> values, you need to pass a function to <code>shinyServer()</code> that takes <code>session</code> as an argument (<code>session</code> is a special object that is used for finer control over a user&#8217;s app session). Once it&#8217;s in there, you can access <code>session$clientData</code> just as you would <code>input</code>.</p>

<p>In the example below, the client browser will display out the components of the URL and also parse and print the query/search string (the part of the URL after a &#8221;<code>?</code>&#8221;):</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>shinyServer(function(input, output, session) {

  # Return the components of the URL in a string:
  output$urlText &lt;- renderText({
    paste(sep = &quot;&quot;,
      &quot;protocol: &quot;, session$clientData$url_protocol, &quot;\n&quot;,
      &quot;hostname: &quot;, session$clientData$url_hostname, &quot;\n&quot;,
      &quot;pathname: &quot;, session$clientData$url_pathname, &quot;\n&quot;,
      &quot;port: &quot;,     session$clientData$url_port,     &quot;\n&quot;,
      &quot;search: &quot;,   session$clientData$url_search,   &quot;\n&quot;
    )
  })

  # Parse the GET query string
  output$queryText &lt;- renderText({
    query &lt;- parseQueryString(session$clientData$url_search)

    # Return a string with key-value pairs
    paste(names(query), query, sep = &quot;=&quot;, collapse=&quot;, &quot;)
  })
})</code></pre>
</div>
<h5 id='uir'>ui.R</h5>
<div>
  <pre><code class='r'>shinyUI(bootstrapPage(
  h3(&quot;URL components&quot;),
  verbatimTextOutput(&quot;urlText&quot;),

  h3(&quot;Parsed query string&quot;),
  verbatimTextOutput(&quot;queryText&quot;)
))</code></pre>
</div>
<p>This app will display the following:</p>

<p><img alt='URL components' src='screenshots/url-components.png' /></p>

<h3 id='viewing_all_available_values_in_clientdata'>Viewing all available values in clientData</h3>

<p>The values in <code>session$clientData</code> will depend to some extent on the outputs. For example, a plot output object will report its height, width, and hidden status. The app below has a plot output, and displays all the values in <code>session$clientData</code>:</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output, session) {
  # Store in a convenience variable
  cdata &lt;- session$clientData

  # Values from cdata returned as text
  output$clientdataText &lt;- renderText({
    cnames &lt;- names(cdata)

    allvalues &lt;- lapply(cnames, function(name) {
      paste(name, cdata[[name]], sep=&quot; = &quot;)
    })
    paste(allvalues, collapse = &quot;\n&quot;)
  })

  # A histogram
  output$myplot &lt;- renderPlot({
    hist(rnorm(input$obs), main=&quot;Generated in renderPlot()&quot;)
  })
})</code></pre>
</div>
<p>Notice that, just as with <code>input</code>, values in <code>session$clientData</code> can be accessed with <code>session$clientData$myvar</code> or <code>session$clientData[[&#39;myvar&#39;]]</code>. Or, equivalently, since we&#8217;ve saved it into a convenience variable <code>cdata</code>, we can use <code>cdata$myvar</code> or <code>cdata[[&#39;myvar&#39;]]</code>.</p>

<h5 id='uir'>ui.R</h5>
<div>
  <pre><code class='r'>shinyUI(pageWithSidebar(
  headerPanel(&quot;Shiny Client Data&quot;),
  sidebarPanel(
    sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;,
                min = 0, max = 1000, value = 500)
  ),
  mainPanel(
    h3(&quot;clientData values&quot;),
    verbatimTextOutput(&quot;clientdataText&quot;),
    plotOutput(&quot;myplot&quot;)
  )
))</code></pre>
</div>
<p>For the plot output <code>output$myplot</code>, there are three entries in <code>clientData</code>:</p>

<ul>
<li><code>output_myplot_height</code>: The height of the plot on the web page, in pixels.</li>

<li><code>output_myplot_width</code>: The width of the plot on the web page, in pixels.</li>

<li><code>output_myplot_hidden</code>: If the object is hidden (not visible), this is TRUE. This is used because Shiny will by default suspend the output object when it is hidden. When suspended, the observer will not execute even when its inputs change.</li>
</ul>

<p>Here is the view from the client, with all the <code>clientData</code> values:</p>

<p><img alt='All clientData values' src='screenshots/clientdata-all.png' /></p>

</div>

<!-- Sending Images -->
<div class="tab-pane" id="sending-images">


<h2 id='sending_images'>Sending Images</h2>

<p>When you want to have R generate a plot and send it to the client browser, the <code>renderPlot()</code> function will in most cases do the job. But when you need finer control over the process, you might need to use the <code>renderImage()</code> function instead.</p>

<h3 id='about_renderplot'>About renderPlot()</h3>

<p><code>renderPlot()</code> is useful for any time where R generates an image using its normal graphical device system. In other words, any plot-generating code that would normally go between <code>png()</code> and <code>dev.off()</code> can be used in <code>renderPlot()</code>. If the following code works from the console, then it should work in <code>renderPlot()</code>:</p>
<div>
  <pre><code class='r'>png()
# Your plotting code here
dev.off()</code></pre>
</div><div>
  <pre><code class='r'># This would go in shinyServer()
output$myPlot &lt;- renderPlot({
  # Your plotting code here
})</code></pre>
</div>
<p><code>renderPlot()</code> takes care of a number of details automatically: it will resize the image to fit the output window, and it will even increase the resolution of the output image when displaying on high-resolution (&#8220;Retina&#8221;) screens.</p>

<p>The limitation to <code>renderPlot()</code> is that it won&#8217;t send just any image file to the browser &#8211; the image must be generated by code that uses R&#8217;s graphical output device system. Other methods of creating images can&#8217;t be sent by <code>renderPlot()</code>. For example, the following won&#8217;t work:</p>

<ul>
<li>Image files generated by the <code>writePNG()</code> function from the png package.</li>

<li>Image files generated by the <code>rgl.snapshot()</code> function, which creates images from 3D plots made with the rgl package.</li>

<li>Images generated by an external program.</li>

<li>Pre-rendered images.</li>
</ul>

<p>The solution in these cases is the <code>renderImage()</code> function.</p>

<h3 id='using_renderimage'>Using renderImage()</h3>

<p>Image files can be sent using <code>renderImage()</code>. The expression that you pass to <code>renderImage()</code> must return a list containing an element named <code>src</code>, which is the path to the file. Here is a very basic example of a Shiny app with an output that generates a plot and sends it with <code>renderImage()</code>:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>shinyServer(function(input, output, session) {
  output$myImage &lt;- renderImage({
    # A temp file to save the output.
    # This file will be removed later by renderImage
    outfile &lt;- tempfile(fileext='.png')

    # Generate the PNG
    png(outfile, width=400, height=300)
    hist(rnorm(input$obs), main=&quot;Generated in renderImage()&quot;)
    dev.off()

    # Return a list containing the filename
    list(src = outfile,
         contentType = 'image/png',
         width = 400,
         height = 300,
         alt = &quot;This is alternate text&quot;)
  }, deleteFile = TRUE)
})</code></pre>
</div>
<h4 id='uir'>ui.r</h4>
<div>
  <pre><code class='r'>shinyUI(pageWithSidebar(
  headerPanel(&quot;renderImage example&quot;),
  sidebarPanel(
    sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;,
                min = 0, max = 1000,  value = 500)
  ),
  mainPanel(
    # Use imageOutput to place the image on the page
    imageOutput(&quot;myImage&quot;)
  )
))</code></pre>
</div>
<p>Each time this output object is re-executed, it creates a new PNG file, saves a plot to it, then returns a list containing the filename along with some other values.</p>

<p>Because the <code>deleteFile</code> argument is <code>TRUE</code>, Shiny will delete the file (specified by the <code>src</code> element) after it sends the data. This is appropriate for a case like this, where the image is created on-the-fly, but it wouldn&#8217;t be appropriate when, for example, your app sends pre-rendered images.</p>

<p>In this particular case, the image file is created with the <code>png()</code> function. But it just as well could have been created with <code>writePNG()</code> from the png package, or by any other method. If you have the filename of the image, you can send it with <code>renderImage()</code>.</p>

<h4 id='structure_of_the_returned_list'>Structure of the returned list</h4>

<p>The list returned in the example above contains the following:</p>

<ul>
<li><code>src</code>: The output file path.</li>

<li><code>contentType</code>: The MIME type of the file. If this is missing, Shiny will try to autodetect the MIME type, from the file extension.</li>

<li><code>width</code> and <code>height</code>: The desired output size, in pixels.</li>

<li><code>alt</code>: Alternate text for the image.</li>
</ul>

<p>Except for <code>src</code> and <code>contentType</code>, all values are passed through directly to the <code>&lt;img&gt;</code> DOM element on the web page. The effect is similar to having an image tag with the following:</p>
<div>
  <pre><code class='xml'>&lt;img src=&quot;...&quot; width=&quot;400&quot; height=&quot;300&quot; alt=&quot;This is alternate text&quot;&gt;</code></pre>
</div>
<p>Note that the <code>src=&quot;...&quot;</code> is shorthand for a longer URL. For browsers that support the <a href='http://en.wikipedia.org/wiki/Data_URI_scheme'>data URI scheme</a>, the <code>src</code> and <code>contentType</code> from the returned list are put together to create a special URL that embeds the data, so the result would be similar to something like this:</p>
<div>
  <pre><code class='xml'>&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAm0AAAGnCAYAAADlkGDxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAgAElEQVR4nOydd3ic1ZX/P2+ZKmlU&quot; 
  width=&quot;400&quot; height=&quot;300&quot; alt=&quot;This is alternate text&quot;&gt;</code></pre>
</div>
<p>For browsers that don&#8217;t support the data URI scheme, Shiny sends a URL that points to the file.</p>

<h3 id='sending_prerendered_images_with_renderimage'>Sending pre-rendered images with renderImage()</h3>

<p>If your Shiny app has pre-rendered images saved in a subdirectory, you can send them using <code>renderImage()</code>. Suppose the images are in the subdirectory <code>images/</code>, and are named <code>image1.jpeg</code>, <code>image2.jpeg</code>, and so on. The following code would send the appropriate image, depending on the value of <code>input$n</code>:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>shinyServer(function(input, output, session) {
  # Send a pre-rendered image, and don't delete the image after sending it
  output$preImage &lt;- renderImage({
    # When input$n is 3, filename is ./images/image3.jpeg
    filename &lt;- normalizePath(file.path('./images',
                              paste('image', input$n, '.jpeg', sep='')))
 
    # Return a list containing the filename and alt text
    list(src = filename,
         alt = paste(&quot;Image number&quot;, input$n))

  }, deleteFile = FALSE)
})</code></pre>
</div>
<p>In this example, <code>deleteFile</code> is <code>FALSE</code> because the images aren&#8217;t ephemeral; we don&#8217;t want Shiny to delete an image after sending it.</p>

<p>Note that this might be less efficient than putting images in <code>www/images</code> and emitting HTML that points to the images, because in the latter case the image will be cached by the browser.</p>

<h3 id='using_clientdata_values'>Using clientData values</h3>

<p>In the first example above, the plot size was fixed at 400 by 300 pixels. For dynamic resizing, it&#8217;s possible to use values from <code>session$clientData</code> to detect the output size.</p>

<p>In the example below, the output object is <code>output$myImage</code>, and the width and height on the client browser are sent via <code>session$clientData$output_myImage_width</code> and <code>session$clientData$output_myImage_height</code>. This example also uses <code>session$clientData$pixelratio</code> to multiply the resolution of the image, so that it appears sharp on high-resolution (Retina) displays:</p>

<h4 id='serverr'>server.R</h4>
<div>
  <pre><code class='r'>shinyServer(function(input, output, session) {

  # A dynamically-sized plot
  output$myImage &lt;- renderImage({
    # Read myImage's width and height. These are reactive values, so this
    # expression will re-run whenever they change.
    width  &lt;- session$clientData$output_myImage_width
    height &lt;- session$clientData$output_myImage_height

    # For high-res displays, this will be greater than 1
    pixelratio &lt;- session$clientData$pixelratio

    # A temp file to save the output.
    outfile &lt;- tempfile(fileext='.png')

    # Generate the image file
    png(outfile, width=width*pixelratio, height=height*pixelratio,
        res=72*pixelratio)
    hist(rnorm(input$obs))
    dev.off()

    # Return a list containing the filename
    list(src = outfile,
         width = width,
         height = height,
         alt = &quot;This is alternate text&quot;)
  }, deleteFile = TRUE)

  # This code reimplements many of the features of `renderPlot()`.
  # The effect of this code is very similar to:
  # renderPlot({
  #   hist(rnorm(input$obs))
  # })
})</code></pre>
</div>
<p>The <code>width</code> and <code>height</code> values passed to <code>png()</code> specify the pixel dimensions of the saved image. These can differ from the <code>width</code> and <code>height</code> values in the returned list: those values are the pixel dimensions to used display the image. For high-res displays (where <code>pixelratio</code> is 2), a &#8220;virtual&#8221; pixel in the browser might correspond to 2 x 2 physical pixels, and a double-resolution image will make use of each of the physical pixels.</p>

</div>

<!-- Reactivity Overview -->
<div class="tab-pane" id="reactivity-overview">


<h2 id='reactivity_overview'>Reactivity Overview</h2>

<p>It&#8217;s easy to build interactive applications with Shiny, but to get the most out of it, you&#8217;ll need to understand the reactive programming model used by Shiny.</p>

<p>In Shiny, there are three kinds of objects in reactive programming: reactive sources, reactive conductors, and reactive endpoints, which are represented with these symbols:</p>

<p><img alt='Reactive roles' src='reactivity_diagrams/roles.png' /></p>

<h3 id='reactive_sources_and_endpoints'>Reactive sources and endpoints</h3>

<p>The simplest structure of a reactive program involves just a source and an endpoint:</p>

<p><img alt='Simplest structure' src='reactivity_diagrams/simplest.png' /></p>

<p>In a Shiny application, the source typically is user input through a browser interface. For example, when the selects an item, types input, or clicks on a button, these actions will set values that are reactive sources. A reactive endpoint is usually something that appears in the user&#8217;s browser window, such as a plot or a table of values.</p>

<p>In a simple Shiny application, reactive sources are accessible through the <code>input</code> object, and reactive endpoints are accessible through the <code>output</code> object. (Actually, there are other possible kinds of sources and endpoints, which we&#8217;ll talk about later, but for now we&#8217;ll just talk about <code>input</code> and <code>output</code>.)</p>

<p>This simple structure, with one source and one endpoint, is used by the <code>01_hello</code> example. The <code>server.R</code> code for that example looks something like this:</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  output$distPlot &lt;- renderPlot({
    hist(rnorm(input$obs))
  })
})</code></pre>
</div>
<p><img alt='Structure of 01_hello' src='reactivity_diagrams/01_hello.png' /></p>

<p>You can see it in action at <a href='http://glimmer.rstudio.com/shiny/01_hello/'>http://glimmer.rstudio.com/shiny/01_hello/</a>.</p>

<p>The <code>output$distPlot</code> object is a reactive endpoint, and it uses the reactive source <code>input$obs</code>. Whenever <code>input$obs</code> changes, <code>output$distPlot</code> is notified that it needs to re-execute. In traditional program with an interactive user interface, this might involve setting up event handlers and writing code to read values and transfer data. Shiny does all these things for you behind the scenes, so that you can simply write code that looks like regular R code.</p>

<p>A reactive source can be connected to multiple endpoints, and vice versa. Here is a slightly more complex Shiny application:</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  output$plotOut &lt;- renderPlot({
    hist(faithful$eruptions, breaks = as.numeric(input$nBreaks))
    if (input$individualObs)
      rug(faithful$eruptions)
  })

  output$tableOut &lt;- renderTable({
    if (input$individualObs)
      faithful
    else
      NULL
  })
})</code></pre>
</div>
<p><img alt='Structure of Old Faithful example' src='reactivity_diagrams/faithful.png' /></p>

<p>In a Shiny application, there&#8217;s no need to explictly describe each of these relationships and tell R what to do when each input component changes; Shiny automatically handles these details for you.</p>

<p>In an app with the structure above, whenever the value of the <code>input$nBreaks</code> changes, the expression that generates the plot will automatically re-execute. Whenever the value of the <code>input$individualObs</code> changes, the plot and table functions will automatically re-execute. (In a Shiny application, most endpoint functions have their results automatically wrapped up and sent to the web browser.)</p>

<h3 id='reactive_conductors'>Reactive conductors</h3>

<p>So far we&#8217;ve seen reactive sources and reactive endpoints, and most simple examples use just these two components, wiring up sources directly to endpoints. It&#8217;s also possible to put reactive components in between the sources and endpoints. These components are called <em>reactive conductors</em>.</p>

<p>A conductor can both be a dependent and have dependents. In other words, it can be both a parent and child in a graph of the reactive structure. Sources can only be parents (they can have dependents), and endpoints can only be children (they can be dependents) in the reactive graph.</p>

<p>Reactive conductors can be useful for encapsulating slow or computationally expensive operations. For example, imagine that you have this application that takes a value <code>input$n</code> and prints the <em>n</em>th value in the Fibonacci sequence, as well as the inverse of <em>n</em>th value in the sequence plus one (note the code in these examples is condensed to illustrate reactive concepts, and doesn&#8217;t necessarily represent coding best practices):</p>
<div>
  <pre><code class='r'># Calculate nth number in Fibonacci sequence
fib &lt;- function(n) ifelse(n&lt;3, 1, fib(n-1)+fib(n-2))

shinyServer(function(input, output) {
  output$nthValue    &lt;- renderText({ fib(as.numeric(input$n)) })
  output$nthValueInv &lt;- renderText({ 1 / fib(as.numeric(input$n)) })
})</code></pre>
</div>
<p>The graph structure of this app is:</p>

<p><img alt='Fibonacci app without conductor' src='reactivity_diagrams/fib_no_conductor.png' /></p>

<p>The <code>fib()</code> algorithm is very inefficient, so we don&#8217;t want to run it more times than is absolutely necessary. But in this app, we&#8217;re running it twice! On a reasonably fast modern machine, setting <code>input$n</code> to 30 takes about 15 seconds to calculate the answer, largely because <code>fib()</code> is run twice.</p>

<p>The amount of computation can be reduced by adding a reactive conductor in between the source and endpoints:</p>
<div>
  <pre><code class='r'>fib &lt;- function(n) ifelse(n&lt;3, 1, fib(n-1)+fib(n-2))

shinyServer(function(input, output) {
  currentFib         &lt;- reactive({ fib(as.numeric(input$n)) })

  output$nthValue    &lt;- renderText({ currentFib() })
  output$nthValueInv &lt;- renderText({ 1 / currentFib() })
})</code></pre>
</div>
<p>Here is the new graph structure:</p>

<p><img alt='Fibonacci app with conductor' src='reactivity_diagrams/conductor.png' /></p>

<p>Keep in mind that if your application tries to access reactive values or expressions from outside a reactive context &#8212; that is, outside of a reactive expression or observer &#8212; then it will result in an error. You can think of there being a reactive &#8220;world&#8221; which can see and change the non-reactive world, but the non-reactive world can&#8217;t do the same to the reactive world. Code like this will not work, because the call to <code>fib()</code> is not in the reactive world (it&#8217;s not in a <code>reactive()</code> or <code>renderXX()</code> call) but it tries to access something that is, the reactive value <code>input$n</code>:</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  # Will give error
  currentFib      &lt;- fib(as.numeric(input$n))
  output$nthValue &lt;- renderText({ currentFib })
})</code></pre>
</div>
<p>On the other hand, if <code>currentFib</code> is a function that accesses a reactive value, and that function is called within the reactive world, then it will work:</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  # OK, as long as this is called from the reactive world:
  currentFib &lt;- function() {
    fib(as.numeric(input$n))
  }

  output$nthValue &lt;- renderText({ currentFib })
})</code></pre>
</div>
<h3 id='summary'>Summary</h3>

<p>In this section, we&#8217;ve learned about:</p>

<ul>
<li><strong>Reactive sources</strong> can signal objects downstream that they need to re-execute.</li>

<li><strong>Reactive conductors</strong> are placed somewhere in between sources and endpoints on the reactive graph. They are typically used for encapsulating slow operations.</li>

<li><strong>Reactive endpoints</strong> can be told to re-execute by the reactive environment, and can request <em>upstream</em> objects to execute.</li>

<li><strong>Invalidation arrows</strong> diagram the flow of invalidation events. It can also be said that the child node is a <strong>dependent of</strong> or <strong>takes a dependency on</strong> the parent node.</li>
</ul>

<h3 id='implementations_of_sources_conductors_and_endpoints_values_expressions_and_observers'>Implementations of sources, conductors, and endpoints: values, expressions, and observers</h3>

<p>We&#8217;ve discussed reactive sources, conductors, and endpoints. These are general terms for parts that play a particular role in a reactive program. Presently, Shiny has one class of objects that act as reactive sources, one class of objects that act as reactive conductors, and one class of objects that act as reactive endpoints, but in principle there could be other classes that implement these roles.</p>

<ul>
<li><strong>Reactive values</strong> are an implementation of Reactive sources; that is, they are an implementation of that role.</li>

<li><strong>Reactive expressions</strong> are an implementation of Reactive conductors. They can access reactive values or other reactive expressions, and they return a value.</li>

<li><strong>Observers</strong> are an implementation of Reactive endpoints. They can access reactive sources and reactive expressions, and they don&#8217;t return a value; they are used for their side effects.</li>
</ul>

<p><img alt='Implementations of reactive roles' src='reactivity_diagrams/roles_implement.png' /></p>

<p>All of the examples use these three implementations, as there are presently no other implementations of the source, conductor, and endpoint roles.</p>

<h3 id='reactive_values'>Reactive values</h3>

<p>Reactive values contain values (not surprisingly), which can be read by other reactive objects. The <code>input</code> object is a <code>ReactiveValues</code> object, which looks something like a list, and it contains many individual reactive values. The values in <code>input</code> are set by input from the web browser.</p>

<h3 id='reactive_expressions'>Reactive expressions</h3>

<p>We&#8217;ve seen reactive expressions in action, with the Fibonacci example above. They cache their return values, to make the app run more efficiently. Note that, abstractly speaking, <em>reactive conductors</em> do not necessarily cache return values, but in this implementation, <em>reactive expressions</em>, they do.</p>

<p>A reactive expressions can be useful for caching the results of any procedure that happens in response to user input, including:</p>

<ul>
<li>accessing a database</li>

<li>reading data from a file</li>

<li>downloading data over the network</li>

<li>performing an expensive computation</li>
</ul>

<h3 id='observers'>Observers</h3>

<p>Observers are similar to reactive expressions, but with a few important differences. Like reactive expressions, they can access reactive values and reactive expressions. However, they do not return any values, and therefore do not cache their return values. Instead of returning values, they have side effects &#8211; typically, this involves sending data to the web browser.</p>

<p>The <code>output</code> object looks something like a list, and it can contain many individual observers.</p>

<p>If you look at the code for <code>renderText()</code> and friends, you&#8217;ll see that they each return a function which returns a value. They&#8217;re typically used like this:</p>
<div>
  <pre><code class='r'>output$number &lt;- renderText({ as.numeric(input$n) + 1 })</code></pre>
</div>
<p>This might lead you to think that the observers <em>do</em> return values. However, this isn&#8217;t the whole story. The function returned by <code>renderText()</code> is actually not an observer/endpoint. When it is assigned to <code>output$x</code>, the function returned by <code>renderText()</code> gets automatically wrapped into another function, which is an observer. The wrapper function is used because it needs to do special things to send the data to the browser.</p>

<h3 id='differences_between_reactive_expressions_and_observers'>Differences between reactive expressions and observers</h3>

<p>Reactive expressions and observers are similar in that they store expressions that can be executed, but they have some fundamental differences.</p>

<ul>
<li>Observers (and endpoints in general) respond to reactive <em>flush</em> events, but reactive expressions (and conductors in general) do not. We&#8217;ll learn more about flush events in the next section. If you want a reactive expression to execute, it must have an observer as a descendant on the reactive dependency graph.</li>

<li>Reactive expressions return values, but observers don&#8217;t.</li>
</ul>

</div>

<!-- Execution Scheduling -->
<div class="tab-pane" id="execution-scheduling">


<h2 id='execution_scheduling'>Execution scheduling</h2>

<p>At the core of Shiny is its reactive engine: this is how Shiny knows when to re-execute each component of an application. We&#8217;ll trace into some examples to get a better understanding of how it works.</p>

<h3 id='a_simple_example'>A simple example</h3>

<p>At an abstract level, we can describe the <code>01_hello</code> example as containing one source and one endpoint. When we talk about it more concretely, we can describe it as having one reactive value, <code>input$obs</code>, and one reactive observer, <code>output$distPlot</code>.</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  output$distPlot &lt;- renderPlot({
    hist(rnorm(input$obs))
  })
})</code></pre>
</div>
<p>As shown in the diagram below, a reactive value has a value. A reactive observer, on the other hand, doesn&#8217;t have a value. Instead, it contains an R expression which, when executed, has some side effect (in most cases, this involves sending data to the web browser). But the observer doesn&#8217;t return a value. Reactive observers have another property: they have a flag that indicates whether they have been <em>invalidated</em>. We&#8217;ll see what that means shortly.</p>

<p><img alt='' src='reactivity_diagrams/01_hello_process_1.png' /></p>

<p>After you load this application in a web page, it be in the state shown above, with <code>input$obs</code> having the value 500 (this is set in the <code>ui.r</code> file, which isn&#8217;t shown here). The arrow represents the direction that invalidations will flow. If you change the value to 1000, it triggers a series of events that result in a new image being sent to your browser.</p>

<p>When the value of <code>input$obs</code> changes, two things happen:</p>

<ul>
<li>All of its descendants in the graph are invalidated. Sometimes for brevity we&#8217;ll say that an observer is <em>dirty</em>, meaning that it is invalidated, or <em>clean</em>, meaning that it is <em>not</em> invalidated.</li>

<li>The arrows that have been followed are removed; they are no longer considered descendants, and changing the reactive value again won&#8217;t have any effect on them. Notice that the arrows are dynamic, not static.</li>
</ul>

<p>In this case, the only descendant is <code>output$distPlot</code>:</p>

<p><img alt='' src='reactivity_diagrams/01_hello_process_2.png' /></p>

<p>Once all the descendants are invalidated, a <em>flush</em> occurs. When this happens, all invalidated observers re-execute.</p>

<p><img alt='' src='reactivity_diagrams/01_hello_process_3.png' /></p>

<p>Remember that the code we assigned to <code>output$distPlot</code> makes use of <code>input$obs</code>:</p>
<div>
  <pre><code class='r'>output$distPlot &lt;- renderPlot({
  hist(rnorm(input$obs))
})</code></pre>
</div>
<p>As <code>output$distPlot</code> re-executes, it accesses the reactive value <code>input$obs</code>. When it does this, it becomes a dependent of that value, represented by the arrow . When <code>input$obs</code> changes, it invalidates all of its children; in this case, that&#8217;s just<code>output$distPlot</code>.</p>

<p><img alt='' src='reactivity_diagrams/01_hello_process_4.png' /></p>

<p>As it finishes executing, <code>output$distPlot</code> creates a PNG image file, which is sent to the browser, and finally it is marked as clean (not invalidated).</p>

<p><img alt='' src='reactivity_diagrams/01_hello_process_5.png' /></p>

<p>Now the cycle is complete, and the application is ready to accept input again.</p>

<p>When someone first starts a session with a Shiny application, all of the endpoints start out invalidated, triggering this series of events.</p>

<h3 id='an_app_with_reactive_conductors'>An app with reactive conductors</h3>

<p>Here&#8217;s the code for our Fibonacci program:</p>
<div>
  <pre><code class='r'>fib &lt;- function(n) ifelse(n&lt;3, 1, fib(n-1)+fib(n-2))

shinyServer(function(input, output) {
  currentFib         &lt;- reactive({ fib(as.numeric(input$n)) })

  output$nthValue    &lt;- renderText({ currentFib() })
  output$nthValueInv &lt;- renderText({ 1 / currentFib() })
})</code></pre>
</div>
<p>Here&#8217;s the structure. It&#8217;s shown in its state after the initial run, with the values and invalidation flags (the starting value for <code>input$n</code> is set in <code>ui.r</code>, which isn&#8217;t displayed).</p>

<p><img alt='' src='reactivity_diagrams/fib_process_1.png' /></p>

<p>Suppose the user sets <code>input$n</code> to 30. This is a new value, so it immediately invalidates its children, <code>currentFib</code>, which in turn invalidates its children, <code>output$nthValue</code> and <code>output$nthValueInv</code>. As the invalidations are made, the invalidation arrows are removed:</p>

<p><img alt='' src='reactivity_diagrams/fib_process_2.png' /></p>

<p>After the invalidations finish, the reactive environment is flushed, so the endpoints re-execute. If a flush occurs when multiple endpoints are invalidated, there isn&#8217;t a guaranteed order that the endpoints will execute, so <code>nthValue</code> may run before <code>nthValueInv</code>, or vice versa. The execution order of endpoints will not affect the results, as long as they don&#8217;t modify and read non-reactive variables (which aren&#8217;t part of the reactive graph).</p>

<p>Suppose in this case that <code>nthValue()</code> executes first. The next several steps are straightforward:</p>

<p><img alt='' src='reactivity_diagrams/fib_process_3.png' /></p>

<p><img alt='' src='reactivity_diagrams/fib_process_4.png' /></p>

<p><img alt='' src='reactivity_diagrams/fib_process_5.png' /></p>

<p><img alt='' src='reactivity_diagrams/fib_process_6.png' /></p>

<p><img alt='' src='reactivity_diagrams/fib_process_7.png' /></p>

<p><img alt='' src='reactivity_diagrams/fib_process_8.png' /></p>

<p>As <code>output$nthValueInv()</code> executes, it calls <code>currentFib()</code>. If <code>currentFib()</code> were an ordinary R expression, it would simply re-execute, taking another several seconds. But it&#8217;s not an ordinary expression; it&#8217;s a reactive expression, and it now happens to be marked clean. Because it is clean, Shiny knows that all of <code>currentFib</code>&#8217;s reactive parents have not changed values since the previous run <code>currentFib()</code>. This means that running the function again would simply return the same value as the previous run. (Shiny assumes that the non-reactive objects used by <code>currentFib()</code> also have not changed. If, for example, it called <code>Sys.time()</code>, then a second run of <code>currentFib()</code> could return a different value. If you wanted the changing values of <code>Sys.time()</code> to be able to invalidate <code>currentFib()</code>, it would have to be wrapped up in an object that acted as a reactive source. If you were to do this, that object would also be added as a node on the reactive graph.)</p>

<p>Acting on this assumption. that clean reactive expressions will return the same value as they did the previous run, Shiny caches the return value when reactive expressions are executed. On subsequent calls to the reactive expression, it simply returns the cached value, without re-executing the expression, as long as it remains clean.</p>

<p>In our example, when <code>output$nthValueInv()</code> calls <code>currentFib()</code>, Shiny just hands it the cached value, 832040. This happens almost instantaneously, instead of taking several more seconds to re-execute <code>currentFib()</code>:</p>

<p><img alt='' src='reactivity_diagrams/fib_process_9.png' /></p>

<p>Finally, <code>output$nthValueInv()</code> takes that value, finds the inverse, and then as a side effect, sends the value to the browser.</p>

<p><img alt='' src='reactivity_diagrams/fib_process_10.png' /></p>

<h3 id='summary'>Summary</h3>

<p>In this section we&#8217;ve learned about:</p>

<ul>
<li><strong>Invalidation flags</strong>: reactive expressions and observers are invalidated (marked dirty) when their parents change or are invalidated, and they are marked as clean after they re-execute.</li>

<li><strong>Arrow creation and removal</strong>: After a parent object follows invalidates its children, the arrows will be removed. New arrows will be created when a reactive object accesses another reactive object.</li>

<li><strong>Flush events</strong> trigger the execution of endpoints. Flush events occur whenever the browser sends data to the server.</li>
</ul>

</div>

<!-- Isolation -->
<div class="tab-pane" id="isolation">


<h2 id='isolation_avoiding_dependency'>Isolation: avoiding dependency</h2>

<p>Sometimes it&#8217;s useful for an observer/endpoint to access a reactive value or expression, but not to take a dependency on it. For example, if the observer performs a long calculation or downloads large data set, you might want it to execute only when a button is clicked.</p>

<p>For this, we&#8217;ll use <code>actionButton</code>. We&#8217;ll define a <code>ui.R</code> that is a slight modification of the one from 01_hello &#8211; the only difference is that it has an actionButton labeled &#8220;Go!&#8221;. You can see it in action at <a href='http://glimmer.rstudio.com/winston/actionbutton/'>http://glimmer.rstudio.com/winston/actionbutton/</a>.</p>

<p>The actionButton includes some JavaScript code that sends numbers to the server. When the web browser first connects, it sends a value of 0, and on each click, it sends an incremented value: 1, 2, 3, and so on.</p>
<div>
  <pre><code class='r'>shinyUI(pageWithSidebar(
  headerPanel(&quot;Click the button&quot;),
  sidebarPanel(
    sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;,
                min = 0, max = 1000, value = 500),
    actionButton(&quot;goButton&quot;, &quot;Go!&quot;)
  ),
  mainPanel(
    plotOutput(&quot;distPlot&quot;)
  )
))</code></pre>
</div>
<p>In our <code>server.R</code>, there are two changes to note. First, <code>output$distPlot</code> will take a dependency on <code>input$goButton</code>, simply by accessing it. When the button is clicked, the value of <code>input$goButton</code> increases, and so <code>output$distPlot</code> re-executes.</p>

<p>The second change is that the access to <code>input$obs</code> is wrapped with <code>isolate()</code>. This function takes an R expression, and it tells Shiny that the calling observer or reactive expression should not take a dependency on any reactive objects inside the expression.</p>
<div>
  <pre><code class='r'>shinyServer(function(input, output) {
  output$distPlot &lt;- renderPlot({
    # Take a dependency on input$goButton
    input$goButton

    # Use isolate() to avoid dependency on input$obs
    dist &lt;- isolate(rnorm(input$obs))
    hist(dist)
  })
})</code></pre>
</div>
<p>The resulting graph looks like this:</p>

<p><img alt='Isolated reactive value' src='reactivity_diagrams/isolate.png' /></p>

<p>And here&#8217;s a walkthrough of the process when <code>input$obs</code> is set to 1000, and then the Go button is clicked:</p>

<p><img alt='' src='reactivity_diagrams/isolate_process_1.png' /></p>

<p><img alt='' src='reactivity_diagrams/isolate_process_2.png' /></p>

<p><img alt='' src='reactivity_diagrams/isolate_process_3.png' /></p>

<p><img alt='' src='reactivity_diagrams/isolate_process_4.png' /></p>

<p><img alt='' src='reactivity_diagrams/isolate_process_5.png' /></p>

<p><img alt='' src='reactivity_diagrams/isolate_process_6.png' /></p>

<p>In the <code>actionButton</code> example, you might want to prevent it from returning a plot the first time, before the button has been clicked. Since the starting value of an <code>actionButton</code> is zero, this can be accomplished with the following:</p>
<div>
  <pre><code class='r'>output$distPlot &lt;- renderPlot({
    if (input$goButton == 0)
      return()

    # plot-making code here
  })</code></pre>
</div>
<p>Reactive values are not the only things that can be isolated; reactive expressions can also be put inside an <code>isolate()</code>. Building off the Fibonacci example from above, this would calculate the <em>n</em>th value only when the button is clicked:</p>
<div>
  <pre><code class='r'>output$nthValue &lt;- renderText({
  if (input$goButton == 0)
    return()

  isolate({ fib(as.numeric(input$n)) })
})</code></pre>
</div>
<p>It&#8217;s also possible to put multiple lines of code in <code>isolate()</code>. For example here are some blocks of code that have equivalent effect:</p>
<div>
  <pre><code class='r'># Separate calls to isolate -------------------------------
x &lt;- isolate({ input$xSlider }) + 100
y &lt;- isolate({ input$ySlider })  * 2
z &lt;- x/y

# Single call to isolate ----------------------------------
isolate({
  x &lt;- input$xSlider + 100
  y &lt;- input$ySlider * 2
  z &lt;- x/y
})

# Single call to isolate, use return value ----------------
z &lt;- isolate({
  x &lt;- input$xSlider + 100
  y &lt;- input$ySlider * 2
  x/y
})</code></pre>
</div>
<p>In all of these cases, the calling function won&#8217;t take a reactive dependency on either of the <code>input</code> variables.</p>

</div>

<!-- Deploying Shiny Apps Over the Web -->
<div class="tab-pane" id="deployment-web">


<h2 id='deploying_over_the_web'>Deploying Over the Web</h2>

<p>Once you&#8217;ve written your Shiny app, you can make it available to anyone who has a web browser, using our Shiny Server software. You can either host the applications on your own server, or let us host your Shiny applications for you.</p>

<p>If you want a simple way to distribute your Shiny app so that users can run them on their own computers, see <a href='#deployment-local'>Deploying Shiny Apps to Run Locally</a>.</p>

<h3 id='selfhosted_shiny_server'>Self-hosted Shiny Server</h3>

<p>With our <a href='https://github.com/rstudio/shiny-server'>Shiny Server</a> software, you can deploy Shiny applications over the web so that users need only a web browser and your application&#8217;s URL. You&#8217;ll need a Linux server and <a href='https://github.com/rstudio/shiny-server'>Shiny Server</a>.</p>

<p>Shiny Server is free and open source, though in the future we will offer a commercially licensed edition with additional features for larger organizations. If you&#8217;d like to be notified of future beta releases of Shiny Server, please <a href='https://rstudio.wufoo.com/forms/shiny-server-beta-program/'>register now</a>.</p>

<h4 id='pros'>Pros</h4>

<ul>
<li>Easiest for your users&#8212;only a web browser is required</li>

<li>Take advantage of centralized computing resources</li>
</ul>

<h4 id='cons'>Cons</h4>

<ul>
<li>Requires server setup and maintenance of a Linux server</li>
</ul>

<h3 id='rstudiohosted_shiny_server'>RStudio-hosted Shiny Server</h3>

<p>Want to deploy over the web but prefer not to run your own server? We&#8217;re currently beta testing a subscription-based hosting service for Shiny. To apply for a free beta test account, <a href='https://rstudio.wufoo.com/forms/shiny-server-beta-program/'>register now</a>.</p>

<h4 id='pros'>Pros</h4>

<ul>
<li>Easiest for your users&#8212;only a web browser is required</li>

<li>No need to run your own server</li>
</ul>

<h4 id='cons'>Cons</h4>

<ul>
<li>Code and data must be copied to our servers</li>
</ul>

</div>

<!-- Sharing Apps to Run Locally -->
<div class="tab-pane" id="deployment-local">


<h2 id='sharing_apps_to_run_locally'>Sharing Apps to Run Locally</h2>

<p>Once you&#8217;ve written your Shiny app, you can distribute it for others to run on their own computers&#8212;they can download and run Shiny apps with a single R command. This requires that they have R and Shiny installed on their computers.</p>

<p>If you want your Shiny app to be accessible over the web, so that users only need a web browser, see <a href='#deployment-web'>Deploying Shiny Apps over the Web</a>.</p>

<p>Here are some ways to deliver Shiny apps to run locally:</p>

<h3 id='gist'>Gist</h3>

<p>One easy way is to put your code on <a href='https://gist.github.com'>gist.github.com</a>, a code pasteboard service from <a href='https://github.com/'>GitHub</a>. Both server.R and ui.R must be included in the same gist, and you must use their proper filenames. See <a href='https://gist.github.com/3239667'>https://gist.github.com/3239667</a> for an example.</p>

<p>Your recipient must have R and the Shiny package installed, and then running the app is as easy as entering the following command:</p>
<pre><code class='r'>shiny::runGist('3239667')</code></pre>
<p>In place of <code>&#39;3239667&#39;</code> you will use your gist&#8217;s ID; or, you can use the entire URL of the gist (e.g. <code>&#39;https://gist.github.com/3239667&#39;</code>).</p>

<h4 id='pros'>Pros</h4>

<ul>
<li>Source code is easily visible by recipient (if desired)</li>

<li>Easy to run (for R users)</li>

<li>Easy to post and update</li>
</ul>

<h4 id='cons'>Cons</h4>

<ul>
<li>Code is published to a third-party server</li>
</ul>

<h3 id='github_repository'>GitHub repository</h3>

<p>If your project is stored in a git repository on GitHub, then others can download and run your app directly. An example repository is at <a href='https://github.com/rstudio/shiny_example'>https://github.com/rstudio/shiny_example</a>. The following command will download and run the application:</p>
<pre><code class='r'>shiny::runGitHub('shiny_example', 'rstudio')</code></pre>
<p>In this example, the GitHub account is <code>&#39;rstudio&#39;</code> and the repository is <code>&#39;shiny_example&#39;</code>; you will need to replace them with your account and repository name.</p>

<h4 id='pros'>Pros</h4>

<ul>
<li>Source code is easily visible by recipient (if desired)</li>

<li>Easy to run (for R users)</li>

<li>Very easy to update if you already use GitHub for your project</li>

<li>Git-savvy users can clone and fork your repository</li>
</ul>

<h4 id='cons'>Cons</h4>

<ul>
<li>Developer must know how to use git and GitHub</li>

<li>Code is hosted by a third-party server</li>
</ul>

<h3 id='zip_file_delivered_over_the_web'>Zip File, delivered over the web</h3>

<p>If you store a zip or tar file of your project on a web or FTP server, users can download and run it with a command like this:</p>
<pre><code class='r'>runUrl('https://github.com/rstudio/shiny_example/archive/master.zip')</code></pre>
<p>The URL in this case is a zip file that happens to be stored on GitHub; replace it with the URL to your zip file.</p>

<h4 id='pros'>Pros</h4>

<ul>
<li>Only requires a web server for delivery</li>
</ul>

<h4 id='cons'>Cons</h4>

<ul>
<li>To view the source, recipient must first download and unzip it</li>
</ul>

<h3 id='zip_file_copied_to_recipients_computer'>Zip File, copied to recipient&#8217;s computer</h3>

<p>Another way is to simply zip up your project directory and send it to your recipient(s), where they can unzip the file and run it the same way you do (<code>shiny::runApp</code>).</p>

<h4 id='pros'>Pros</h4>

<ul>
<li>Share apps using e-mail, USB flash drive, or any other way you can transfer a file</li>
</ul>

<h4 id='cons'>Cons</h4>

<ul>
<li>Updates to app must be sent manually</li>
</ul>

<h3 id='package'>Package</h3>

<p>If your Shiny app is useful to a broader audience, it might be worth the effort to turn it into an R package. Put your Shiny application directory under the package&#8217;s <code>inst</code> directory, then create and export a function that contains something like this:</p>
<pre><code class='r'>shiny::runApp(system.file('<em>appdir</em>', package='<em>packagename</em>'))</code></pre>
<p>where <code>appdir</code> is the name of your app&#8217;s subdirectory in <code>inst</code>, and <code>packagename</code> is the name of your package.</p>

<h4 id='pros'>Pros</h4>

<ul>
<li>Publishable on CRAN</li>

<li>Easy to run (for R users)</li>
</ul>

<h4 id='cons'>Cons</h4>

<ul>
<li>More work to set up</li>

<li>Source code is visible by recipient (if not desired)</li>
</ul>

</div>

<!-- Building Inputs -->
<div class="tab-pane" id="building-inputs">


<h2 id='building_inputs'>Building Inputs</h2>

<p>Shiny comes equipped with a variety of useful input components, but as you build more ambitious applications, you may find yourself needing input widgets that we don&#8217;t include. Fortunately, Shiny is designed to let you create your own custom input components. If you can implement it using HTML, CSS, and JavaScript, you can use it as a Shiny input!</p>

<p>(If you&#8217;re only familiar with R and not with HTML/CSS/JavaScript, then you will likely find it tough to create all but the simplest custom input components on your own. However, other people can&#160;&#8211; and hopefully will&#160;&#8211; bundle up their custom Shiny input components as R packages and make them available to the rest of the community.)</p>

<h3 id='design_the_component'>Design the Component</h3>

<p>The first steps in creating a custom input component is no different than in any other form of web development. You write HTML markup that lays out the component, CSS rules to style it, and use JavaScript (mostly event handlers) to give it behavior, if necessary.</p>

<p>Shiny input components should try to adhere to the following principles, if possible:</p>

<ul>
<li><strong>Designed to be used from HTML and R:</strong> Shiny user interfaces can either be written using R code (that generates HTML), or by writing the HTML directly. A well-designed Shiny input component will take both styles into account: offer an R function for creating the component, but also have thoughtfully designed and documented HTML markup.</li>

<li><strong>Configurable using HTML attributes:</strong> Avoid requiring the user to make JavaScript calls to configure the component. Instead, it&#8217;s better to use HTML attributes. In your component&#8217;s JavaScript logic, you can <a href='http://api.jquery.com/data/#data-html5'>easily access these values using jQuery</a> (or simply by reading the DOM attribute directly).</li>
</ul>

<p>When used in a Shiny application, your component&#8217;s HTML markup will be repeated once for each instance of the component on the page, but the CSS and JavaScript will generally only need to appear once, most likely in the <code>&lt;head&gt;</code>. For R-based interface code, you can use the functions <code>singleton</code> and <code>tags$head</code> together to ensure these tags appear once and only once, in the head. (See the full example below.)</p>

<h3 id='write_an_input_binding'>Write an Input Binding</h3>

<p>Each custom input component also needs an <em>input binding</em>, an object you create that tells Shiny how to identify instances of your component and how to interact with them. (Note that each <em>instance</em> of the input component doesn&#8217;t need its own input binding object; rather, all instances of a particular type of input component share a single input binding object.)</p>

<p>An input binding object needs to have the following methods:</p>
<dl>
  <dt>
    <code>find(scope)</code>
  </dt>
  <dd>
    <p>
      Given an HTML document or element (<code>scope</code>), find any descendant elements that are an instance of your component and return them as an array (or array-like object). The other input binding methods all take an <code>el</code> argument; that value will always be an element that was returned from <code>find</code>.
    </p>

    <p>
      A very common implementation is to use jQuery's <code>find</code> method to identify elements with a specific class, for example:
    </p>
<pre>exampleInputBinding.find = function(scope) {
  return $(scope).find(".exampleComponentClass");
};</pre>
  </dd>
  <dt>
    <code>getId(el)</code>
  </dt>
  <dd>
    Return the Shiny input ID for the element <code>el</code>, or <code>null</code> if the element doesn't have an ID and should therefore be ignored. The default implementation in <code>Shiny.InputBinding</code> reads the <code>data-input-id</code> attribute and falls back to the element's <code>id</code> if not present.
  </dd>
  <dt>
    <code>getValue(el)</code>
  </dt>
  <dd>
    Return the Shiny value for the element <code>el</code>. This can be any JSON-compatible value.
  </dd>
  <dt>
    <code>setValue(el, value)</code>
  </dt>
  <dd>
    Set the element to the specified value. (This is not currently used, but in the future we anticipate adding features that will require the server to push input values to the client.)
  </dd>
  <dt>
    <code>subscribe(el, callback)</code>
  </dt>
  <dd>
    <p>
      Subscribe to DOM events on the element <code>el</code> that indicate the value has changed. When the DOM events fire, call <code>callback</code> (a function) which will tell Shiny to retrieve the value.
    </p>
    <p>
      We recommend using jQuery's event namespacing feature when subscribing, as unsubscribing becomes very easy (see <code>unsubscribe</code>, below). In this example, <code>exampleComponentName</code> is used as a namespace:
    </p>
<pre>exampleInputBinding.subscribe = function(el, callback) {
  $(el).on("keyup.exampleComponentName", function(event) {
    callback(true);
  });
  $(el).on("change.exampleComponentName", function(event) {
    callback();
  });
};</pre>
    <p>
      Later on, we can unsubscribe <code>".exampleComponentName"</code> which will remove all of our handlers without touching anyone else's.
    </p>
    <p>
      The <code>callback</code> function optionally takes an argument: a boolean value that indicates whether the component's rate policy should apply (<code>true</code> means the rate policy should apply). See <code>getRatePolicy</code> below for more details.
    </p>
  </dd>
  <dt>
    <code>unsubscribe(el)</code>
  </dt>
  <dd>
    <p>Unsubscribe DOM event listeners that were bound in <code>subscribe</code>.</p>
    <p>Example:</p>
<pre><code class='javascript'>exampleInputBinding.unsubscribe = function(el) {
  $(el).off(".exampleComponentName");
};</code></pre>
  </dd>
  <dt>
    <code>getRatePolicy()</code>
  </dt>
  <dd>
    <p>Return an object that describes the rate policy of this component (or <code>null</code> for default).</p>
    <p>
      Rate policies are helpful for slowing down the rate at which input events get sent to the server. For example, as the user drags a slider from value A to value B, dozens of change events may occur. It would be wasteful to send all of those events to the server, where each event would potentially cause expensive computations to occur.
    </p>
    <p>
      A rate policy slows down the rate of events using one of two algorithms (so far). <strong>Throttling</strong> means no more than one event will be sent per X milliseconds. <strong>Debouncing</strong> means all of the events will be ignored until no events have been received for X milliseconds, at which time the most recent event will be sent. <a href='http://benalman.com/projects/jquery-throttle-debounce-plugin/'>This blog post</a> goes into more detail about the difference between throttle and debounce.
    </p>
    <p>
      A rate policy object has two members:
    </p>
    <ul>
      <li>
        <code>policy</code> - Valid values are the strings <code>"direct"</code>, <code>"debounce"</code>, and <code>"throttle"</code>. <code>"direct"</code> means that all events are sent immediately.
      </li>
      <li>
        <code>delay</code> - Number indicating the number of milliseconds that should be used when debouncing or throttling. Has no effect if the policy is <code>direct</code>.
      </li>
    </ul>
    <p>
      Rate policies are only applied when the <code>callback</code> function in <code>subscribe</code> is called with <code>true</code> as the first parameter. It's important that input components be able to control which events are rate-limited and which are not, as different events may have different expectations to the user. For example, for a textbox, it would make sense to rate-limit events while the user is typing, but if the user hits Enter or focus leaves the textbox, then the input should always be sent immediately.
    </p>
  </dd>
</dl>
<h3 id='register_input_binding'>Register Input Binding</h3>

<p>Once you&#8217;ve created an input binding object, you need to tell Shiny to use it: <pre><code class='javascript'>Shiny.inputBindings.register(exampleInputBinding, "yourname.exampleInputBinding");</code></pre></p>

<p>The second argument is a name the user can use to change the priority of the binding. On the off chance that the user has multiple bindings that all want to claim the same HTML element as their own, this call can be used to control the priority of the bindings:</p>
<pre><code class='javascript'>Shiny.inputBindings.setPriority("yourname.exampleInputBinding", 10);</code></pre>
<p>Higher numbers indicate a higher priority; the default priority is 0. All of Shiny&#8217;s built-in input component bindings default to a priority of 0.</p>

<p>If two bindings have the same priority value, then the more recently registered binding has the higher priority.</p>

<h3 id='example'>Example</h3>

<p>For this example, we&#8217;ll create a button that displays a number, whose value increases by one each time the button is clicked. Here&#8217;s what the end result will look like:</p>
<p>
  <button class='increment btn' type='button'>0</button>​​​​​​​​​​​​​​​​​​​​​​​
</p><script>
$(document).on("click", "button.increment", function(evt) {
  // evt.target is the button that was clicked
  var el = $(evt.target);
  // Set the button's text to its current value plus 1
  el.text(parseInt(el.text()) + 1);
  // Raise an event to signal that the value changed
  el.trigger("change");
});
</script>
<p>To start, let&#8217;s design the HTML markup for this component:</p>
<pre><code class='html'>&lt;button id="inputId" class="increment btn" type="button">0&lt;/button>​​​​​​​​​​​​​​​​​​​​​​​</code></pre>
<p>The CSS class <code>increment</code> is what will differentiate our buttons from any other kind of buttons. (The <code>btn</code> class is just to make the button look decent in <a href='http://twitter.github.com/bootstrap'>Twitter Bootstrap</a>.)</p>

<p>Now we&#8217;ll write the JavaScript that drives the button&#8217;s basic behavior:</p>
<pre><code class='javascript'>$(document).on("click", "button.increment", function(evt) {

  // evt.target is the button that was clicked
  var el = $(evt.target);

  // Set the button's text to its current value plus 1
  el.text(parseInt(el.text()) + 1);

  // Raise an event to signal that the value changed
  el.trigger("change");
});</code></pre>
<p>This code uses <a href='http://api.jquery.com/on/'>jQuery&#8217;s delegated events feature</a> to bind all increment buttons at once.</p>

<p>Now we&#8217;ll create the Shiny binding object for our component, and register it:</p>
<pre><code class='javascript'>var incrementBinding = new Shiny.InputBinding();
$.extend(incrementBinding, {
  find: function(scope) {
    return $(scope).find(".increment");
  },
  getValue: function(el) {
    return parseInt($(el).text());
  },
  setValue: function(el, value) {
    $(el).text(value);
  },
  subscribe: function(el, callback) {
    $(el).on("change.incrementBinding", function(e) {
      callback();
    });
  },
  unsubscribe: function(el) {
    $(el).off(".incrementBinding");
  }
});

Shiny.inputBindings.register(incrementBinding);</code></pre>
<p>Both the behavioral JavaScript code and the Shiny binding code should generally be run when the page loads. (It&#8217;s important that they run before Shiny initialization, which occurs after all the document ready event handlers are executed.)</p>

<p>The cleanest way to do this is to put both chunks of JavaScript into a file. In this case, we&#8217;ll use the path <code>./www/js/increment.js</code>, which we can then access as <code>http://localhost:8100/js/increment.js</code>.</p>

<p>If you&#8217;re using an <code>index.html</code> style user interface, you&#8217;ll just need to add this line to your <code>&lt;head&gt;</code> (make sure it comes after the script tag that loads <code>shiny.js</code>):</p>
<pre><code class='html'>&lt;script src="js/increment.js"&gt;&lt;/script&gt;</code></pre>
<p>On the other hand, if you&#8217;re using <code>ui.R</code>, then you can define this function before the call to <code>shinyUI</code>:</p>
<pre><code class='r'>incrementButton &lt;- function(inputId, value = 0) {
  tagList(
    singleton(tags$head(tags$script(src = "js/increment.js"))),
    tags$button(id = inputId,
                class = "increment btn",
                type = "button",
                as.character(value))
  )
}</code></pre>
<p>Then in your <code>shinyUI</code> page definition you can call <code>incrementButton</code> wherever you want an increment button rendered. Notice the line that begins with <code>singleton</code> will ensure that the <code>increment.js</code> file will be included just one time, in the <code>&lt;head&gt;</code>, no matter how many buttons you insert into the page or where you place them.</p>

</div>

<!-- Building Outputs -->
<div class="tab-pane" id="building-outputs">


<h2 id='building_outputs'>Building Outputs</h2>

<p>Right out of the box, Shiny makes it easy to include plots, simple tables, and text as outputs in your application; but we imagine that you&#8217;ll also want to display outputs that don&#8217;t fit into those categories. Perhaps you need an interactive <a href='http://en.wikipedia.org/wiki/Choropleth_map'>choropleth map</a> or a <a href='http://code.google.com/p/google-motion-charts-with-r/'>googleVis motion chart</a>.</p>

<p>Similar to <a href='#building-inputs'>custom inputs</a>, if you have some knowledge of HTML/CSS/JavaScript you can also build reusable, custom output components. And you can bundle up output components as R packages for other Shiny users to use.</p>

<h3 id='serverside_output_functions'>Server-Side Output Functions</h3>

<p>Start by deciding the kind of values your output component is going to receive from the user&#8217;s server side R code.</p>

<p>Whatever value the user&#8217;s R code returns is going to need to somehow be turned into a JSON-compatible value (Shiny uses <a href='http://cran.r-project.org/web/packages/RJSONIO/index.html'>RJSONIO</a> to do the conversion). If the user&#8217;s code is naturally going to return something RJSONIO-compatible&#160;&#8211; like a character vector, a data frame, or even a list that contains atomic vectors&#160;&#8211; then you can just direct the user to use a function on the server. However, if the output needs to undergo some other kind of transformation, then you&#8217;ll need to write a wrapper function that your users will use instead (analogous to <code>renderPlot</code> or <code>renderTable</code>).</p>

<p>For example, if the user wants to output <a href='http://stat.ethz.ch/R-manual/R-patched/library/stats/html/ts.html'>time series objects</a> then you might create a <code>renderTimeSeries</code> function that knows how to translate <code>ts</code> objects to a simple list or data frame:</p>
<div>
  <pre><code class='r'>renderTimeSeries &lt;- function(expr, env=parent.frame(), quoted=FALSE) {
    # Convert the expression + environment into a function
    func &lt;- exprToFunction(expr, env, quoted)

    function() {
      val &lt;- func()
      list(start = tsp(val)[1],
           end = tsp(val)[2],
           freq = tsp(val)[3],
           data = as.vector(val))
    }
}</code></pre>
</div>
<p>which would then be used by the user like so:</p>
<div>
  <pre><code class='r'>output$timeSeries1 &lt;- renderTimeSeries({
    ts(matrix(rnorm(300), 100, 3), start=c(1961, 1), frequency=12)
})</code></pre>
</div>
<h3 id='design_output_component_markup'>Design Output Component Markup</h3>

<p>At this point, we&#8217;re ready to design the HTML markup and write the JavaScript code for our output component.</p>

<p>For many components, you&#8217;ll be able to have extremely simple HTML markup, something like this:</p>
<div>
  <pre><code class='html'>&lt;div id=&quot;timeSeries1&quot; class=&quot;timeseries-output&quot;&gt;&lt;/div&gt;</code></pre>
</div>
<p>We&#8217;ll use the <code>timeseries-output</code> CSS class as an indicator that the element is one that we should bind to. When new output values for <code>timeSeries1</code> come down from the server, we&#8217;ll fill up the div with our visualization using JavaScript.</p>

<h3 id='write_an_output_binding'>Write an Output Binding</h3>

<p>Each custom output component needs an <em>output binding</em>, an object you create that tells Shiny how to identify instances of your component and how to interact with them. (Note that each <em>instance</em> of the output component doesn&#8217;t need its own output binding object; rather, all instances of a particular type of output component share a single output binding object.)</p>

<p>An output binding object needs to have the following methods:</p>
<dl>
  <dt>
    <code>find(scope)</code>
  </dt>
  <dd>
    <p>
      Given an HTML document or element (<code>scope</code>), find any descendant elements that are an instance of your component and return them as an array (or array-like object). The other output binding methods all take an <code>el</code> argument; that value will always be an element that was returned from <code>find</code>.
    </p>

    <p>
      A very common implementation is to use jQuery's <code>find</code> method to identify elements with a specific class, for example:
    </p>
<pre>exampleOutputBinding.find = function(scope) {
  return $(scope).find(".exampleComponentClass");
};</pre>
  </dd>
  <dt>
    <code>getId(el)</code>
  </dt>
  <dd>
    Return the Shiny output ID for the element <code>el</code>, or <code>null</code> if the element doesn't have an ID and should therefore be ignored. The default implementation in <code>Shiny.OutputBinding</code> reads the <code>data-output-id</code> attribute and falls back to the element's <code>id</code> if not present.
  </dd>
  <dt>
    <code>renderValue(el, data)</code>
  </dt>
  <dd>
    Called when a new value that matches this element's ID is received from the server. The function should render the data on the element. The type/shape of the `data` argument depends on the server logic that generated it; whatever value is returned from the R code is converted to JSON using the RJSONIO package.
  </dd>
  <dt>
    <code>renderError(el, err)</code>
  </dt>
  <dd>
    Called when the server attempts to update the output value for this element, and an error occurs. The function should render the error on the element. <code>err</code> is an object with a <code>message</code> String property.
  </dd>
  <dt>
    <code>clearError(el)</code>
  </dt>
  <dd>
    If the element <code>el</code> is currently displaying an error, clear it.
  </dd>
</dl>
<h3 id='register_output_binding'>Register Output Binding</h3>

<p>Once you&#8217;ve created an output binding object, you need to tell Shiny to use it:</p>
<div>
  <pre><code class='javascript'>Shiny.outputBindings.register(exampleOutputBinding, &quot;yourname.exampleOutputBinding&quot;);</code></pre>
</div>
<p>The second argument is a string that uniquely identifies your output binding. At the moment it is unused but future features may depend on it.</p>

</div>

<ul class="pager">
   <li><a href="#" id="previous">&larr; Previous</a></li> 
   <li><a href="#" id="next">Next &rarr;</a></li> 
</ul>

</div>

</div>
</div>


<!-- Placed at the end of the document so the pages load faster -->
<script src="jquery.ba-hashchange.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script>
function manageNextPrev() {
   $('a#next').parent().toggleClass('disabled', $('.nav li.active').nextAll('li:not(.nav-header)').size() == 0);
   $('a#previous').parent().toggleClass('disabled', $('.nav li.active').prevAll('li:not(.nav-header)').size() == 0);
}
manageNextPrev();

$('a#next').click(function(e) {
   e.preventDefault();
   location.href = $('.nav li.active').nextAll('li:not(.nav-header)').first().find('a').attr('href');
   manageNextPrev();
   window.scrollTo(0,10);
});
$('a#previous').click(function(e) {
   e.preventDefault();
   location.href = $('.nav li.active').prevAll('li:not(.nav-header)').first().find('a').attr('href');
   manageNextPrev();
   window.scrollTo(0,10);
});

$(window).hashchange(function() {
  $('.tab-pane').hide();
  var tab = location.hash || '#welcome';
  $(tab + '.tab-pane').show();

  $('.nav li.active').removeClass('active');
  $('.nav li a[href="' + tab + '"]').parent().addClass('active');
  manageNextPrev();
});
$(window).hashchange();
</script>

<script type="text/javascript">    
        $(document).ready(function(){ 
            $('.tab-pane a').each(function(index,element){
                var href = $(this).attr('href');
                if(href.indexOf('#') == 0){
                    $(this).attr('target','_self');
                }
            });           
        });	
</script>


</body>
</html>
